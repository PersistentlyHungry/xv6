{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"path",
				"path"
			],
			[
				"str",
				"strlen"
			],
			[
				"strc",
				"safestrcpy"
			],
			[
				"pa",
				"path_variable"
			],
			[
				"co",
				"continue"
			],
			[
				"MAX",
				"MAX_PATH_ENTRIES"
			],
			[
				"do",
				"do"
			]
		]
	},
	"buffers":
	[
		{
			"file": "console.c",
			"settings":
			{
				"buffer_size": 5158,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "\nSearching 173 files for \"str\"\n\n/home/oron/os142/assignment1/LICENSE:\n    6  Permission is hereby granted, free of charge, to any person obtaining\n    7  a copy of this software and associated documentation files (the\n    8: \"Software\"), to deal in the Software without restriction, including\n    9  without limitation the rights to use, copy, modify, merge, publish,\n   10: distribute, sublicense, and/or sell copies of the Software, and to\n   11  permit persons to whom the Software is furnished to do so, subject to\n   12  the following conditions:\n\n/home/oron/os142/assignment1/Makefile:\n   17  	proc.o\\\n   18  	spinlock.o\\\n   19: 	string.o\\\n   20  	swtch.o\\\n   21  	syscall.o\\\n   ..\n   73  OBJCOPY = $(TOOLPREFIX)objcopy\n   74  OBJDUMP = $(TOOLPREFIX)objdump\n   75: #CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer\n   76: CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer\n   77  CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)\n   78  ASFLAGS = -m32 -gdwarf-2 -Wa,-divide\n   ..\n  161  	_rm\\\n  162  	_sh\\\n  163: 	_stressfs\\\n  164  	_usertests\\\n  165  	_wc\\\n  ...\n  233  EXTRA=\\\n  234  	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\\\n  235: 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\\\n  236  	printf.c umalloc.c\\\n  237  	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\\\n\n/home/oron/os142/assignment1/Notes:\n   51  trap() ought to lgdt on return, since currently only done in swtch()\n   52  \n   53: protect hardware interrupt vectors from user INT instructions?\n   54  \n   55  test out-of-fd cases for creating pipe.\n   ..\n   89    no-one is allowed to do anything to the inode\n   90    protected by inode_table_lock\n   91: inode->count counts in-memory pointers to the struct\n   92    prevents inode[] element from being re-used\n   93    protected by inode_table_lock\n\n/home/oron/os142/assignment1/README:\n    1  xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix\n    2: Version 6 (v6).  xv6 loosely follows the structure and style of v6,\n    3  but is implemented for a modern x86-based multiprocessor using ANSI C.\n    4  \n\n/home/oron/os142/assignment1/TRICKS:\n   20  the first time a process returns to user space, and\n   21  at that point, cp->tf is set to point to a trap frame\n   22: constructed at the top of cp's kernel stack.  So tf \n   23  *is* a valid %esp that can hold interrupt state.\n   24  \n   ..\n   79  The x86's processor-ordering memory model \n   80  matches spin locks well, so no explicit memory\n   81: synchronization instructions are required in\n   82  acquire and release.  \n   83  \n   ..\n  107  \n  108  According to the Intel manual behavior spec, the\n  109: second condition requires a serialization instruction\n  110  in release, to avoid reads in A happening after giving\n  111  up lk.  No Intel SMP processor in existence actually\n\n/home/oron/os142/assignment1/bio.c:\n    1  // Buffer cache.\n    2  //\n    3: // The buffer cache is a linked list of buf structures holding\n    4  // cached copies of disk block contents.  Caching disk blocks\n    5  // in memory reduces the number of disk reads and also provides\n    .\n   27  #include \"buf.h\"\n   28  \n   29: struct {\n   30:   struct spinlock lock;\n   31:   struct buf buf[NBUF];\n   32  \n   33    // Linked list of all buffers, through prev/next.\n   34    // head.next is most recently used.\n   35:   struct buf head;\n   36  } bcache;\n   37  \n   ..\n   39  binit(void)\n   40  {\n   41:   struct buf *b;\n   42  \n   43    initlock(&bcache.lock, \"bcache\");\n   ..\n   59  // If not found, allocate fresh block.\n   60  // In either case, return B_BUSY buffer.\n   61: static struct buf*\n   62  bget(uint dev, uint sector)\n   63  {\n   64:   struct buf *b;\n   65  \n   66    acquire(&bcache.lock);\n   ..\n   94  \n   95  // Return a B_BUSY buf with the contents of the indicated disk sector.\n   96: struct buf*\n   97  bread(uint dev, uint sector)\n   98  {\n   99:   struct buf *b;\n  100  \n  101    b = bget(dev, sector);\n  ...\n  107  // Write b's contents to disk.  Must be B_BUSY.\n  108  void\n  109: bwrite(struct buf *b)\n  110  {\n  111    if((b->flags & B_BUSY) == 0)\n  ...\n  118  // Move to the head of the MRU list.\n  119  void\n  120: brelse(struct buf *b)\n  121  {\n  122    if((b->flags & B_BUSY) == 0)\n\n/home/oron/os142/assignment1/bootasm.S:\n   37    outb    %al,$0x60\n   38  \n   39:   # Switch from real to protected mode.  Use a bootstrap GDT that makes\n   40    # virtual addresses map directly to physical addresses so that the\n   41    # effective memory map doesn't change during the transition.\n   ..\n   76    jmp     spin\n   77  \n   78: # Bootstrap GDT\n   79  .p2align 2                                # force 4 byte alignment\n   80  gdt:\n\n/home/oron/os142/assignment1/bootblock.asm:\n   56      7c1b:	e6 60                	out    %al,$0x60\n   57  \n   58:   # Switch from real to protected mode.  Use a bootstrap GDT that makes\n   59    # virtual addresses map directly to physical addresses so that the\n   60    # effective memory map doesn't change during the transition.\n   ..\n  323    uchar* pa;\n  324  \n  325:   elf = (struct elfhdr*)0x10000;  // scratch space\n  326  \n  327    // Read 1st page off disk\n  ...\n  342  \n  343    // Load each program segment (ignores ph flags).\n  344:   ph = (struct proghdr*)((uchar*)elf + elf->phoff);\n  345      7d67:	8b 1d 1c 00 01 00    	mov    0x1001c,%ebx\n  346      7d6d:	81 c3 00 00 01 00    	add    $0x10000,%ebx\n  ...\n  381  \n  382    // Load each program segment (ignores ph flags).\n  383:   ph = (struct proghdr*)((uchar*)elf + elf->phoff);\n  384    eph = ph + elf->phnum;\n  385    for(; ph < eph; ph++){\n\n/home/oron/os142/assignment1/bootmain.c:\n   18  bootmain(void)\n   19  {\n   20:   struct elfhdr *elf;\n   21:   struct proghdr *ph, *eph;\n   22    void (*entry)(void);\n   23    uchar* pa;\n   24  \n   25:   elf = (struct elfhdr*)0x10000;  // scratch space\n   26  \n   27    // Read 1st page off disk\n   ..\n   33  \n   34    // Load each program segment (ignores ph flags).\n   35:   ph = (struct proghdr*)((uchar*)elf + elf->phoff);\n   36    eph = ph + elf->phnum;\n   37    for(; ph < eph; ph++){\n\n/home/oron/os142/assignment1/buf.h:\n    1: struct buf {\n    2    int flags;\n    3    uint dev;\n    4    uint sector;\n    5:   struct buf *prev; // LRU cache list\n    6:   struct buf *next;\n    7:   struct buf *qnext; // disk queue\n    8    uchar data[512];\n    9  };\n\n/home/oron/os142/assignment1/cat.asm:\n  171   144:	c3                   	ret    \n  172  \n  173: 00000145 <strcpy>:\n  174  #include \"user.h\"\n  175  #include \"x86.h\"\n  176  \n  177  char*\n  178: strcpy(char *s, char *t)\n  179  {\n  180   145:	55                   	push   %ebp\n  ...\n  199   16c:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  200   170:	84 c0                	test   %al,%al\n  201:  172:	75 de                	jne    152 <strcpy+0xd>\n  202      ;\n  203    return os;\n  ...\n  207   178:	c3                   	ret    \n  208  \n  209: 00000179 <strcmp>:\n  210  \n  211  int\n  212: strcmp(const char *p, const char *q)\n  213  {\n  214   179:	55                   	push   %ebp\n  215   17a:	89 e5                	mov    %esp,%ebp\n  216    while(*p && *p == *q)\n  217:  17c:	eb 08                	jmp    186 <strcmp+0xd>\n  218      p++, q++;\n  219   17e:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  222  \n  223  int\n  224: strcmp(const char *p, const char *q)\n  225  {\n  226    while(*p && *p == *q)\n  ...\n  228   189:	0f b6 00             	movzbl (%eax),%eax\n  229   18c:	84 c0                	test   %al,%al\n  230:  18e:	74 10                	je     1a0 <strcmp+0x27>\n  231   190:	8b 45 08             	mov    0x8(%ebp),%eax\n  232   193:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  234   199:	0f b6 00             	movzbl (%eax),%eax\n  235   19c:	38 c2                	cmp    %al,%dl\n  236:  19e:	74 de                	je     17e <strcmp+0x5>\n  237      p++, q++;\n  238    return (uchar)*p - (uchar)*q;\n  ...\n  250   1b9:	c3                   	ret    \n  251  \n  252: 000001ba <strlen>:\n  253  \n  254  uint\n  255: strlen(char *s)\n  256  {\n  257   1ba:	55                   	push   %ebp\n  ...\n  262    for(n = 0; s[n]; n++)\n  263   1c0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  264:  1c7:	eb 04                	jmp    1cd <strlen+0x13>\n  265   1c9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  266   1cd:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  269   1d5:	0f b6 00             	movzbl (%eax),%eax\n  270   1d8:	84 c0                	test   %al,%al\n  271:  1da:	75 ed                	jne    1c9 <strlen+0xf>\n  272      ;\n  273    return n;\n  ...\n  299   204:	c3                   	ret    \n  300  \n  301: 00000205 <strchr>:\n  302  \n  303  char*\n  304: strchr(const char *s, char c)\n  305  {\n  306   205:	55                   	push   %ebp\n  ...\n  310   20e:	88 45 fc             	mov    %al,-0x4(%ebp)\n  311    for(; *s; s++)\n  312:  211:	eb 14                	jmp    227 <strchr+0x22>\n  313      if(*s == c)\n  314   213:	8b 45 08             	mov    0x8(%ebp),%eax\n  315   216:	0f b6 00             	movzbl (%eax),%eax\n  316   219:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  317:  21c:	75 05                	jne    223 <strchr+0x1e>\n  318        return (char*)s;\n  319   21e:	8b 45 08             	mov    0x8(%ebp),%eax\n  320:  221:	eb 13                	jmp    236 <strchr+0x31>\n  321  }\n  322  \n  323  char*\n  324: strchr(const char *s, char c)\n  325  {\n  326    for(; *s; s++)\n  ...\n  329   22a:	0f b6 00             	movzbl (%eax),%eax\n  330   22d:	84 c0                	test   %al,%al\n  331:  22f:	75 e2                	jne    213 <strchr+0xe>\n  332      if(*s == c)\n  333        return (char*)s;\n  ...\n  411  \n  412  int\n  413: stat(char *n, struct stat *st)\n  414  {\n  415   2ab:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/cat.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 cat.c\n   ..\n   23  0000079d morecore\n   24  00000000 \n   25: 00000145 strcpy\n   26  00000505 printf\n   27  00000344 memmove\n   ..\n   47  000001e1 memset\n   48  00000068 main\n   49: 00000179 strcmp\n   50  00000400 dup\n   51  00000ba0 buf\n   ..\n   56  00000388 exit\n   57  000002f9 atoi\n   58: 000001ba strlen\n   59  000003c8 open\n   60: 00000205 strchr\n   61  000003f0 mkdir\n   62  000003b0 close\n\n/home/oron/os142/assignment1/console.c:\n   19  static int panicked = 0;\n   20  \n   21: static struct {\n   22:   struct spinlock lock;\n   23    int locking;\n   24  } cons;\n   ..\n  175  \n  176  #define INPUT_BUF 128\n  177: struct {\n  178:   struct spinlock lock;\n  179    char buf[INPUT_BUF];\n  180    uint r;  // Read index\n  ...\n  226  \n  227  int\n  228: consoleread(struct inode *ip, char *dst, int n)\n  229  {\n  230    uint target;\n  ...\n  264  \n  265  int\n  266: consolewrite(struct inode *ip, char *buf, int n)\n  267  {\n  268    int i;\n\n/home/oron/os142/assignment1/defs.h:\n    1: struct buf;\n    2: struct context;\n    3: struct file;\n    4: struct inode;\n    5: struct pipe;\n    6: struct proc;\n    7: struct spinlock;\n    8: struct stat;\n    9: struct superblock;\n   10  \n   11  // bio.c\n   12  void            binit(void);\n   13: struct buf*     bread(uint, uint);\n   14: void            brelse(struct buf*);\n   15: void            bwrite(struct buf*);\n   16  \n   17  // console.c\n   ..\n   25  \n   26  // file.c\n   27: struct file*    filealloc(void);\n   28: void            fileclose(struct file*);\n   29: struct file*    filedup(struct file*);\n   30  void            fileinit(void);\n   31: int             fileread(struct file*, char*, int n);\n   32: int             filestat(struct file*, struct stat*);\n   33: int             filewrite(struct file*, char*, int n);\n   34  \n   35  // fs.c\n   36: void            readsb(int dev, struct superblock *sb);\n   37: int             dirlink(struct inode*, char*, uint);\n   38: struct inode*   dirlookup(struct inode*, char*, uint*);\n   39: struct inode*   ialloc(uint, short);\n   40: struct inode*   idup(struct inode*);\n   41  void            iinit(void);\n   42: void            ilock(struct inode*);\n   43: void            iput(struct inode*);\n   44: void            iunlock(struct inode*);\n   45: void            iunlockput(struct inode*);\n   46: void            iupdate(struct inode*);\n   47  int             namecmp(const char*, const char*);\n   48: struct inode*   namei(char*);\n   49: struct inode*   nameiparent(char*, char*);\n   50: int             readi(struct inode*, char*, uint, uint);\n   51: void            stati(struct inode*, struct stat*);\n   52: int             writei(struct inode*, char*, uint, uint);\n   53  \n   54  // ide.c\n   55  void            ideinit(void);\n   56  void            ideintr(void);\n   57: void            iderw(struct buf*);\n   58  \n   59  // ioapic.c\n   ..\n   81  // log.c\n   82  void            initlog(void);\n   83: void            log_write(struct buf*);\n   84  void            begin_trans();\n   85  void            commit_trans();\n   ..\n   96  \n   97  // pipe.c\n   98: int             pipealloc(struct file**, struct file**);\n   99: void            pipeclose(struct pipe*, int);\n  100: int             piperead(struct pipe*, char*, int);\n  101: int             pipewrite(struct pipe*, char*, int);\n  102  \n  103  //PAGEBREAK: 16\n  104  // proc.c\n  105: struct proc*    copyproc(struct proc*);\n  106  void            exit(void);\n  107  int             fork(void);\n  ...\n  112  void            scheduler(void) __attribute__((noreturn));\n  113  void            sched(void);\n  114: void            sleep(void*, struct spinlock*);\n  115  void            userinit(void);\n  116  int             wait(void);\n  ...\n  119  \n  120  // swtch.S\n  121: void            swtch(struct context**, struct context*);\n  122  \n  123  // spinlock.c\n  124: void            acquire(struct spinlock*);\n  125  void            getcallerpcs(void*, uint*);\n  126: int             holding(struct spinlock*);\n  127: void            initlock(struct spinlock*, char*);\n  128: void            release(struct spinlock*);\n  129  void            pushcli(void);\n  130  void            popcli(void);\n  131  \n  132: // string.c\n  133  int             memcmp(const void*, const void*, uint);\n  134  void*           memmove(void*, const void*, uint);\n  135  void*           memset(void*, int, uint);\n  136: char*           safestrcpy(char*, const char*, int);\n  137: int             strlen(const char*);\n  138: int             strncmp(const char*, const char*, uint);\n  139: char*           strncpy(char*, const char*, int);\n  140  \n  141  // syscall.c\n  142  int             argint(int, int*);\n  143  int             argptr(int, char**, int);\n  144: int             argstr(int, char**);\n  145: int             fetchint(struct proc*, uint, int*);\n  146: int             fetchstr(struct proc*, uint, char**);\n  147  void            syscall(void);\n  148  \n  ...\n  154  extern uint     ticks;\n  155  void            tvinit(void);\n  156: extern struct spinlock tickslock;\n  157  \n  158  // uart.c\n  ...\n  171  void            freevm(pde_t*);\n  172  void            inituvm(pde_t*, char*, uint);\n  173: int             loaduvm(pde_t*, char*, struct inode*, uint, uint);\n  174  pde_t*          copyuvm(pde_t*, uint);\n  175: void            switchuvm(struct proc*);\n  176  void            switchkvm(void);\n  177  int             copyout(pde_t*, uint, void*, uint);\n\n/home/oron/os142/assignment1/dot-bochsrc:\n   67  # The ROM BIOS controls what the PC does when it first powers on.\n   68  # Normally, you can use a precompiled BIOS in the source or binary\n   69: # distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded\n   70  # starting at address 0xf0000, and it is exactly 64k long.\n   71  # You can also use the environment variable $BXSHARE to specify the\n   72  # location of the BIOS.\n   73  # The usage of external large BIOS images (up to 512k) at memory top is\n   74: # now supported, but we still recommend to use the BIOS distributed with\n   75  # Bochs. Now the start address can be calculated from image size.\n   76  #=======================================================================\n   ..\n   89  #\n   90  #  IPS:\n   91: #  Emulated Instructions Per Second.  This is the number of IPS that bochs\n   92  #  is capable of running on your machine. You can recompile Bochs with\n   93  #  --enable-show-ips option enabled, to find your workstation's capability.\n   ..\n  235  #   biosdetect= type of biosdetection [none|auto], only for disks on ata0 [cmos]\n  236  #   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]\n  237: #   model=      string returned by identify device command\n  238  #   journal=    optional filename of the redolog for undoable and volatile disks\n  239  #   \n  ...\n  352  #=======================================================================\n  353  # LOGPREFIX:\n  354: # This handles the format of the string prepended to each log line.\n  355  # You may use those special tokens :\n  356  #   %t : 11 decimal digits timer tick\n  357  #   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)\n  358  #   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)\n  359: #   %d : 5 characters string of the device, between brackets\n  360  # \n  361  # Default : %t%e%d\n  ...\n  371  # Bochs now has four severity levels for event logging.\n  372  #   panic: cannot proceed.  If you choose to continue after a panic, \n  373: #          don't be surprised if you get strange behavior or crashes.\n  374  #   error: something went wrong, but it is probably safe to continue the\n  375  #          simulation.\n  ...\n  418  # Other serial modes are 'null' (no input/output), 'file' (output to a file\n  419  # specified as the 'dev' parameter), 'raw' (use the real serial port - under\n  420: # construction for win32), 'mouse' (standard serial mouse - requires\n  421  # mouse option setting 'type=serial' or 'type=serial_wheel') and 'socket'\n  422  # (connect a networking socket).\n  ...\n  458  #      1=output to device (system dependent. midi denotes the device driver)\n  459  #      2=SMF file output, including headers\n  460: #      3=output the midi data stream to the file (no midi headers and no\n  461  #        delta times, just command and data bytes)\n  462  # wave: This is the device/file where wave output is stored\n  ...\n  465  #      1=output to device (system dependent. wave denotes the device driver)\n  466  #      2=VOC file output, incl. headers\n  467: #      3=output the raw wave stream to the file\n  468  # log:  The file to write the sb16 emulator messages to.\n  469  # loglevel:\n  ...\n  489  # virtual seconds.  The default is 40000, about 25Hz. Keep in mind that\n  490  # you must tweak the 'cpu: ips=N' directive to be as close to the number\n  491: # of emulated instructions-per-second your workstation can do, for this\n  492  # to be accurate.\n  493  #\n  ...\n  587  # address), and you cannot use ff:ff:ff:ff:ff:ff because that's the broadcast\n  588  # address.  For the ethertap module, you must use fe:fd:00:00:00:01.  There may\n  589: # be other restrictions too.  To be safe, just use the b0:c4... address.\n  590  #\n  591  # ethdev: The ethdev value is the name of the network interface on your host\n  ...\n  606  #   null: All packets are discarded, but logged to a few files.\n  607  #   arpback: ARP is simulated. Disabled by default.\n  608: #   vde:  Virtual Distributed Ethernet\n  609  #   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.\n  610  #         The virtual host uses 192.168.10.1.\n  ...\n  650  # USER_SHORTCUT:\n  651  # This defines the keyboard shortcut to be sent when you press the \"user\"\n  652: # button in the headerbar. The shortcut string is a combination of maximum\n  653  # 3 key names (listed below) separated with a '-' character. The old-style\n  654  # syntax (without the '-') still works for the key combinations supported\n\n/home/oron/os142/assignment1/echo.asm:\n   88    90:	c3                   	ret    \n   89  \n   90: 00000091 <strcpy>:\n   91  #include \"user.h\"\n   92  #include \"x86.h\"\n   93  \n   94  char*\n   95: strcpy(char *s, char *t)\n   96  {\n   97    91:	55                   	push   %ebp\n   ..\n  116    b8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  117    bc:	84 c0                	test   %al,%al\n  118:   be:	75 de                	jne    9e <strcpy+0xd>\n  119      ;\n  120    return os;\n  ...\n  124    c4:	c3                   	ret    \n  125  \n  126: 000000c5 <strcmp>:\n  127  \n  128  int\n  129: strcmp(const char *p, const char *q)\n  130  {\n  131    c5:	55                   	push   %ebp\n  132    c6:	89 e5                	mov    %esp,%ebp\n  133    while(*p && *p == *q)\n  134:   c8:	eb 08                	jmp    d2 <strcmp+0xd>\n  135      p++, q++;\n  136    ca:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  139  \n  140  int\n  141: strcmp(const char *p, const char *q)\n  142  {\n  143    while(*p && *p == *q)\n  ...\n  145    d5:	0f b6 00             	movzbl (%eax),%eax\n  146    d8:	84 c0                	test   %al,%al\n  147:   da:	74 10                	je     ec <strcmp+0x27>\n  148    dc:	8b 45 08             	mov    0x8(%ebp),%eax\n  149    df:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  151    e5:	0f b6 00             	movzbl (%eax),%eax\n  152    e8:	38 c2                	cmp    %al,%dl\n  153:   ea:	74 de                	je     ca <strcmp+0x5>\n  154      p++, q++;\n  155    return (uchar)*p - (uchar)*q;\n  ...\n  167   105:	c3                   	ret    \n  168  \n  169: 00000106 <strlen>:\n  170  \n  171  uint\n  172: strlen(char *s)\n  173  {\n  174   106:	55                   	push   %ebp\n  ...\n  179    for(n = 0; s[n]; n++)\n  180   10c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  181:  113:	eb 04                	jmp    119 <strlen+0x13>\n  182   115:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  183   119:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  186   121:	0f b6 00             	movzbl (%eax),%eax\n  187   124:	84 c0                	test   %al,%al\n  188:  126:	75 ed                	jne    115 <strlen+0xf>\n  189      ;\n  190    return n;\n  ...\n  216   150:	c3                   	ret    \n  217  \n  218: 00000151 <strchr>:\n  219  \n  220  char*\n  221: strchr(const char *s, char c)\n  222  {\n  223   151:	55                   	push   %ebp\n  ...\n  227   15a:	88 45 fc             	mov    %al,-0x4(%ebp)\n  228    for(; *s; s++)\n  229:  15d:	eb 14                	jmp    173 <strchr+0x22>\n  230      if(*s == c)\n  231   15f:	8b 45 08             	mov    0x8(%ebp),%eax\n  232   162:	0f b6 00             	movzbl (%eax),%eax\n  233   165:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  234:  168:	75 05                	jne    16f <strchr+0x1e>\n  235        return (char*)s;\n  236   16a:	8b 45 08             	mov    0x8(%ebp),%eax\n  237:  16d:	eb 13                	jmp    182 <strchr+0x31>\n  238  }\n  239  \n  240  char*\n  241: strchr(const char *s, char c)\n  242  {\n  243    for(; *s; s++)\n  ...\n  246   176:	0f b6 00             	movzbl (%eax),%eax\n  247   179:	84 c0                	test   %al,%al\n  248:  17b:	75 e2                	jne    15f <strchr+0xe>\n  249      if(*s == c)\n  250        return (char*)s;\n  ...\n  328  \n  329  int\n  330: stat(char *n, struct stat *st)\n  331  {\n  332   1f7:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/echo.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 echo.c\n   ..\n   23  000006e9 morecore\n   24  00000000 \n   25: 00000091 strcpy\n   26  00000451 printf\n   27  00000290 memmove\n   ..\n   46  0000012d memset\n   47  00000000 main\n   48: 000000c5 strcmp\n   49  0000034c dup\n   50  000001f7 stat\n   ..\n   54  000002d4 exit\n   55  00000245 atoi\n   56: 00000106 strlen\n   57  00000314 open\n   58: 00000151 strchr\n   59  0000033c mkdir\n   60  000002fc close\n\n/home/oron/os142/assignment1/elf.h:\n    4  \n    5  // File header\n    6: struct elfhdr {\n    7    uint magic;  // must equal ELF_MAGIC\n    8    uchar elf[12];\n    .\n   19    ushort shentsize;\n   20    ushort shnum;\n   21:   ushort shstrndx;\n   22  };\n   23  \n   24  // Program section header\n   25: struct proghdr {\n   26    uint type;\n   27    uint off;\n\n/home/oron/os142/assignment1/entry.S:\n   57    # Jump to main(), and switch to executing at\n   58    # high addresses. The indirect call is needed because\n   59:   # the assembler produces a PC-relative instruction\n   60    # for a direct jump.\n   61    mov $main, %eax\n\n/home/oron/os142/assignment1/exec.c:\n   17  exec(char *path, char **argv)\n   18  {\n   19:   safestrcpy(path_variable[0],\"/os/\",sizeof(path_variable[0]));\n   20    char *s, *last;\n   21    int i, off;\n   22    uint argc, sz, sp, ustack[3+MAXARG+1];\n   23:   struct elfhdr elf;\n   24:   struct inode *ip;\n   25:   struct proghdr ph;\n   26    pde_t *pgdir, *oldpgdir;\n   27  \n   ..\n   74    sp = sz;\n   75  \n   76:   // Push argument strings, prepare rest of stack in ustack.\n   77    for(argc = 0; argv[argc]; argc++) {\n   78      if(argc >= MAXARG)\n   79        goto bad;\n   80:     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;\n   81:     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)\n   82        goto bad;\n   83      ustack[3+argc] = sp;\n   ..\n   97      if(*s == '/')\n   98        last = s+1;\n   99:   safestrcpy(proc->name, last, sizeof(proc->name));\n  100  \n  101    // Commit to the user image.\n\n/home/oron/os142/assignment1/file.c:\n   10  #include \"spinlock.h\"\n   11  \n   12: struct devsw devsw[NDEV];\n   13: struct {\n   14:   struct spinlock lock;\n   15:   struct file file[NFILE];\n   16  } ftable;\n   17  \n   ..\n   22  }\n   23  \n   24: // Allocate a file structure.\n   25: struct file*\n   26  filealloc(void)\n   27  {\n   28:   struct file *f;\n   29  \n   30    acquire(&ftable.lock);\n   ..\n   41  \n   42  // Increment ref count for file f.\n   43: struct file*\n   44: filedup(struct file *f)\n   45  {\n   46    acquire(&ftable.lock);\n   ..\n   54  // Close file f.  (Decrement ref count, close when reaches 0.)\n   55  void\n   56: fileclose(struct file *f)\n   57  {\n   58:   struct file ff;\n   59  \n   60    acquire(&ftable.lock);\n   ..\n   81  // Get metadata about file f.\n   82  int\n   83: filestat(struct file *f, struct stat *st)\n   84  {\n   85    if(f->type == FD_INODE){\n   ..\n   94  // Read from file f.\n   95  int\n   96: fileread(struct file *f, char *addr, int n)\n   97  {\n   98    int r;\n   ..\n  115  // Write to file f.\n  116  int\n  117: filewrite(struct file *f, char *addr, int n)\n  118  {\n  119    int r;\n\n/home/oron/os142/assignment1/file.h:\n    1: struct file {\n    2    enum { FD_NONE, FD_PIPE, FD_INODE } type;\n    3    int ref; // reference count\n    4    char readable;\n    5    char writable;\n    6:   struct pipe *pipe;\n    7:   struct inode *ip;\n    8    uint off;\n    9  };\n   ..\n   11  \n   12  // in-memory copy of an inode\n   13: struct inode {\n   14    uint dev;           // Device number\n   15    uint inum;          // Inode number\n   ..\n   29  // table mapping major device number to\n   30  // device functions\n   31: struct devsw {\n   32:   int (*read)(struct inode*, char*, int);\n   33:   int (*write)(struct inode*, char*, int);\n   34  };\n   35  \n   36: extern struct devsw devsw[];\n   37  \n   38  #define CONSOLE 1\n\n/home/oron/os142/assignment1/forktest.asm:\n   15     1:	89 e5                	mov    %esp,%ebp\n   16     3:	83 ec 18             	sub    $0x18,%esp\n   17:   write(fd, s, strlen(s));\n   18     6:	8b 45 0c             	mov    0xc(%ebp),%eax\n   19     9:	89 04 24             	mov    %eax,(%esp)\n   20:    c:	e8 9d 01 00 00       	call   1ae <strlen>\n   21    11:	89 44 24 08          	mov    %eax,0x8(%esp)\n   22    15:	8b 45 0c             	mov    0xc(%ebp),%eax\n   ..\n  186   138:	c3                   	ret    \n  187  \n  188: 00000139 <strcpy>:\n  189  #include \"user.h\"\n  190  #include \"x86.h\"\n  191  \n  192  char*\n  193: strcpy(char *s, char *t)\n  194  {\n  195   139:	55                   	push   %ebp\n  ...\n  214   160:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  215   164:	84 c0                	test   %al,%al\n  216:  166:	75 de                	jne    146 <strcpy+0xd>\n  217      ;\n  218    return os;\n  ...\n  222   16c:	c3                   	ret    \n  223  \n  224: 0000016d <strcmp>:\n  225  \n  226  int\n  227: strcmp(const char *p, const char *q)\n  228  {\n  229   16d:	55                   	push   %ebp\n  230   16e:	89 e5                	mov    %esp,%ebp\n  231    while(*p && *p == *q)\n  232:  170:	eb 08                	jmp    17a <strcmp+0xd>\n  233      p++, q++;\n  234   172:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  237  \n  238  int\n  239: strcmp(const char *p, const char *q)\n  240  {\n  241    while(*p && *p == *q)\n  ...\n  243   17d:	0f b6 00             	movzbl (%eax),%eax\n  244   180:	84 c0                	test   %al,%al\n  245:  182:	74 10                	je     194 <strcmp+0x27>\n  246   184:	8b 45 08             	mov    0x8(%ebp),%eax\n  247   187:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  249   18d:	0f b6 00             	movzbl (%eax),%eax\n  250   190:	38 c2                	cmp    %al,%dl\n  251:  192:	74 de                	je     172 <strcmp+0x5>\n  252      p++, q++;\n  253    return (uchar)*p - (uchar)*q;\n  ...\n  265   1ad:	c3                   	ret    \n  266  \n  267: 000001ae <strlen>:\n  268  \n  269  uint\n  270: strlen(char *s)\n  271  {\n  272   1ae:	55                   	push   %ebp\n  ...\n  277    for(n = 0; s[n]; n++)\n  278   1b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  279:  1bb:	eb 04                	jmp    1c1 <strlen+0x13>\n  280   1bd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  281   1c1:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  284   1c9:	0f b6 00             	movzbl (%eax),%eax\n  285   1cc:	84 c0                	test   %al,%al\n  286:  1ce:	75 ed                	jne    1bd <strlen+0xf>\n  287      ;\n  288    return n;\n  ...\n  314   1f8:	c3                   	ret    \n  315  \n  316: 000001f9 <strchr>:\n  317  \n  318  char*\n  319: strchr(const char *s, char c)\n  320  {\n  321   1f9:	55                   	push   %ebp\n  ...\n  325   202:	88 45 fc             	mov    %al,-0x4(%ebp)\n  326    for(; *s; s++)\n  327:  205:	eb 14                	jmp    21b <strchr+0x22>\n  328      if(*s == c)\n  329   207:	8b 45 08             	mov    0x8(%ebp),%eax\n  330   20a:	0f b6 00             	movzbl (%eax),%eax\n  331   20d:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  332:  210:	75 05                	jne    217 <strchr+0x1e>\n  333        return (char*)s;\n  334   212:	8b 45 08             	mov    0x8(%ebp),%eax\n  335:  215:	eb 13                	jmp    22a <strchr+0x31>\n  336  }\n  337  \n  338  char*\n  339: strchr(const char *s, char c)\n  340  {\n  341    for(; *s; s++)\n  ...\n  344   21e:	0f b6 00             	movzbl (%eax),%eax\n  345   221:	84 c0                	test   %al,%al\n  346:  223:	75 e2                	jne    207 <strchr+0xe>\n  347      if(*s == c)\n  348        return (char*)s;\n  ...\n  426  \n  427  int\n  428: stat(char *n, struct stat *st)\n  429  {\n  430   29f:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/forktest.c:\n   11  printf(int fd, char *s, ...)\n   12  {\n   13:   write(fd, s, strlen(s));\n   14  }\n   15  \n\n/home/oron/os142/assignment1/fs.c:\n   22  \n   23  #define min(a, b) ((a) < (b) ? (a) : (b))\n   24: static void itrunc(struct inode*);\n   25  \n   26  // Read the super block.\n   27  void\n   28: readsb(int dev, struct superblock *sb)\n   29  {\n   30:   struct buf *bp;\n   31    \n   32    bp = bread(dev, 1);\n   ..\n   39  bzero(int dev, int bno)\n   40  {\n   41:   struct buf *bp;\n   42    \n   43    bp = bread(dev, bno);\n   ..\n   54  {\n   55    int b, bi, m;\n   56:   struct buf *bp;\n   57:   struct superblock sb;\n   58  \n   59    bp = 0;\n   ..\n   80  bfree(int dev, uint b)\n   81  {\n   82:   struct buf *bp;\n   83:   struct superblock sb;\n   84    int bi, m;\n   85  \n   ..\n   98  //\n   99  // An inode describes a single unnamed file.\n  100: // The inode disk structure holds metadata: the file's type,\n  101  // its size, the number of links referring to it, and the\n  102  // list of blocks holding the file's content.\n  ...\n  157  // multi-step atomic operations.\n  158  \n  159: struct {\n  160:   struct spinlock lock;\n  161:   struct inode inode[NINODE];\n  162  } icache;\n  163  \n  ...\n  168  }\n  169  \n  170: static struct inode* iget(uint dev, uint inum);\n  171  \n  172  //PAGEBREAK!\n  173  // Allocate a new inode with the given type on device dev.\n  174  // A free inode has a type of zero.\n  175: struct inode*\n  176  ialloc(uint dev, short type)\n  177  {\n  178    int inum;\n  179:   struct buf *bp;\n  180:   struct dinode *dip;\n  181:   struct superblock sb;\n  182  \n  183    readsb(dev, &sb);\n  ...\n  185    for(inum = 1; inum < sb.ninodes; inum++){\n  186      bp = bread(dev, IBLOCK(inum));\n  187:     dip = (struct dinode*)bp->data + inum%IPB;\n  188      if(dip->type == 0){  // a free inode\n  189        memset(dip, 0, sizeof(*dip));\n  ...\n  200  // Copy a modified in-memory inode to disk.\n  201  void\n  202: iupdate(struct inode *ip)\n  203  {\n  204:   struct buf *bp;\n  205:   struct dinode *dip;\n  206  \n  207    bp = bread(ip->dev, IBLOCK(ip->inum));\n  208:   dip = (struct dinode*)bp->data + ip->inum%IPB;\n  209    dip->type = ip->type;\n  210    dip->major = ip->major;\n  ...\n  220  // and return the in-memory copy. Does not lock\n  221  // the inode and does not read it from disk.\n  222: static struct inode*\n  223  iget(uint dev, uint inum)\n  224  {\n  225:   struct inode *ip, *empty;\n  226  \n  227    acquire(&icache.lock);\n  ...\n  255  // Increment reference count for ip.\n  256  // Returns ip to enable ip = idup(ip1) idiom.\n  257: struct inode*\n  258: idup(struct inode *ip)\n  259  {\n  260    acquire(&icache.lock);\n  ...\n  267  // Reads the inode from disk if necessary.\n  268  void\n  269: ilock(struct inode *ip)\n  270  {\n  271:   struct buf *bp;\n  272:   struct dinode *dip;\n  273  \n  274    if(ip == 0 || ip->ref < 1)\n  ...\n  283    if(!(ip->flags & I_VALID)){\n  284      bp = bread(ip->dev, IBLOCK(ip->inum));\n  285:     dip = (struct dinode*)bp->data + ip->inum%IPB;\n  286      ip->type = dip->type;\n  287      ip->major = dip->major;\n  ...\n  299  // Unlock the given inode.\n  300  void\n  301: iunlock(struct inode *ip)\n  302  {\n  303    if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)\n  ...\n  316  // to it, free the inode (and its content) on disk.\n  317  void\n  318: iput(struct inode *ip)\n  319  {\n  320    acquire(&icache.lock);\n  ...\n  338  // Common idiom: unlock, then put.\n  339  void\n  340: iunlockput(struct inode *ip)\n  341  {\n  342    iunlock(ip);\n  ...\n  355  // If there is no such block, bmap allocates one.\n  356  static uint\n  357: bmap(struct inode *ip, uint bn)\n  358  {\n  359    uint addr, *a;\n  360:   struct buf *bp;\n  361  \n  362    if(bn < NDIRECT){\n  ...\n  390  // not an open file or current directory).\n  391  static void\n  392: itrunc(struct inode *ip)\n  393  {\n  394    int i, j;\n  395:   struct buf *bp;\n  396    uint *a;\n  397  \n  ...\n  421  // Copy stat information from inode.\n  422  void\n  423: stati(struct inode *ip, struct stat *st)\n  424  {\n  425    st->dev = ip->dev;\n  ...\n  433  // Read data from inode.\n  434  int\n  435: readi(struct inode *ip, char *dst, uint off, uint n)\n  436  {\n  437    uint tot, m;\n  438:   struct buf *bp;\n  439  \n  440    if(ip->type == T_DEV){\n  ...\n  461  // Write data to inode.\n  462  int\n  463: writei(struct inode *ip, char *src, uint off, uint n)\n  464  {\n  465    uint tot, m;\n  466:   struct buf *bp;\n  467  \n  468    if(ip->type == T_DEV){\n  ...\n  498  namecmp(const char *s, const char *t)\n  499  {\n  500:   return strncmp(s, t, DIRSIZ);\n  501  }\n  502  \n  503  // Look for a directory entry in a directory.\n  504  // If found, set *poff to byte offset of entry.\n  505: struct inode*\n  506: dirlookup(struct inode *dp, char *name, uint *poff)\n  507  {\n  508    uint off, inum;\n  509:   struct dirent de;\n  510  \n  511    if(dp->type != T_DIR)\n  ...\n  531  // Write a new directory entry (name, inum) into the directory dp.\n  532  int\n  533: dirlink(struct inode *dp, char *name, uint inum)\n  534  {\n  535    int off;\n  536:   struct dirent de;\n  537:   struct inode *ip;\n  538  \n  539    // Check that name is not present.\n  ...\n  551    }\n  552  \n  553:   strncpy(de.name, name, DIRSIZ);\n  554    de.inum = inum;\n  555    if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))\n  ...\n  602  // If parent != 0, return the inode for the parent and copy the final\n  603  // path element into name, which must have room for DIRSIZ bytes.\n  604: static struct inode*\n  605  namex(char *path, int nameiparent, char *name)\n  606  {\n  607:   struct inode *ip, *next;\n  608  \n  609    if(*path == '/')\n  ...\n  637  }\n  638  \n  639: struct inode*\n  640  namei(char *path)\n  641  {\n  ...\n  644  }\n  645  \n  646: struct inode*\n  647  nameiparent(char *path, char *name)\n  648  {\n\n/home/oron/os142/assignment1/fs.h:\n   13  \n   14  // File system super block\n   15: struct superblock {\n   16    uint size;         // Size of file system image (blocks)\n   17    uint nblocks;      // Number of data blocks\n   ..\n   24  #define MAXFILE (NDIRECT + NINDIRECT)\n   25  \n   26: // On-disk inode structure\n   27: struct dinode {\n   28    short type;           // File type\n   29    short major;          // Major device number (T_DEV only)\n   ..\n   35  \n   36  // Inodes per block.\n   37: #define IPB           (BSIZE / sizeof(struct dinode))\n   38  \n   39  // Block containing inode i\n   ..\n   46  #define BBLOCK(b, ninodes) (b/BPB + (ninodes)/IPB + 3)\n   47  \n   48: // Directory is a file containing a sequence of dirent structures.\n   49  #define DIRSIZ 14\n   50  \n   51: struct dirent {\n   52    ushort inum;\n   53    char name[DIRSIZ];\n\n/home/oron/os142/assignment1/grep.asm:\n   27      p = buf;\n   28    18:	c7 45 f0 60 0e 00 00 	movl   $0xe60,-0x10(%ebp)\n   29:     while((q = strchr(p, '\\n')) != 0){\n   30    1f:	eb 53                	jmp    74 <grep+0x74>\n   31        *q = 0;\n   ..\n   66      m += n;\n   67      p = buf;\n   68:     while((q = strchr(p, '\\n')) != 0){\n   69    74:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)\n   70    7b:	00 \n   71    7c:	8b 45 f0             	mov    -0x10(%ebp),%eax\n   72    7f:	89 04 24             	mov    %eax,(%esp)\n   73:   82:	e8 c2 03 00 00       	call   449 <strchr>\n   74    87:	89 45 e8             	mov    %eax,-0x18(%ebp)\n   75    8a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)\n   ..\n  255   21b:	e8 39 00 00 00       	call   259 <matchhere>\n  256   220:	eb 35                	jmp    257 <match+0x5c>\n  257:   do{  // must look at empty string\n  258      if(matchhere(re, text))\n  259   222:	8b 45 0c             	mov    0xc(%ebp),%eax\n  ...\n  438   388:	c3                   	ret    \n  439  \n  440: 00000389 <strcpy>:\n  441  #include \"user.h\"\n  442  #include \"x86.h\"\n  443  \n  444  char*\n  445: strcpy(char *s, char *t)\n  446  {\n  447   389:	55                   	push   %ebp\n  ...\n  466   3b0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  467   3b4:	84 c0                	test   %al,%al\n  468:  3b6:	75 de                	jne    396 <strcpy+0xd>\n  469      ;\n  470    return os;\n  ...\n  474   3bc:	c3                   	ret    \n  475  \n  476: 000003bd <strcmp>:\n  477  \n  478  int\n  479: strcmp(const char *p, const char *q)\n  480  {\n  481   3bd:	55                   	push   %ebp\n  482   3be:	89 e5                	mov    %esp,%ebp\n  483    while(*p && *p == *q)\n  484:  3c0:	eb 08                	jmp    3ca <strcmp+0xd>\n  485      p++, q++;\n  486   3c2:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  489  \n  490  int\n  491: strcmp(const char *p, const char *q)\n  492  {\n  493    while(*p && *p == *q)\n  ...\n  495   3cd:	0f b6 00             	movzbl (%eax),%eax\n  496   3d0:	84 c0                	test   %al,%al\n  497:  3d2:	74 10                	je     3e4 <strcmp+0x27>\n  498   3d4:	8b 45 08             	mov    0x8(%ebp),%eax\n  499   3d7:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  501   3dd:	0f b6 00             	movzbl (%eax),%eax\n  502   3e0:	38 c2                	cmp    %al,%dl\n  503:  3e2:	74 de                	je     3c2 <strcmp+0x5>\n  504      p++, q++;\n  505    return (uchar)*p - (uchar)*q;\n  ...\n  517   3fd:	c3                   	ret    \n  518  \n  519: 000003fe <strlen>:\n  520  \n  521  uint\n  522: strlen(char *s)\n  523  {\n  524   3fe:	55                   	push   %ebp\n  ...\n  529    for(n = 0; s[n]; n++)\n  530   404:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  531:  40b:	eb 04                	jmp    411 <strlen+0x13>\n  532   40d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  533   411:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  536   419:	0f b6 00             	movzbl (%eax),%eax\n  537   41c:	84 c0                	test   %al,%al\n  538:  41e:	75 ed                	jne    40d <strlen+0xf>\n  539      ;\n  540    return n;\n  ...\n  566   448:	c3                   	ret    \n  567  \n  568: 00000449 <strchr>:\n  569  \n  570  char*\n  571: strchr(const char *s, char c)\n  572  {\n  573   449:	55                   	push   %ebp\n  ...\n  577   452:	88 45 fc             	mov    %al,-0x4(%ebp)\n  578    for(; *s; s++)\n  579:  455:	eb 14                	jmp    46b <strchr+0x22>\n  580      if(*s == c)\n  581   457:	8b 45 08             	mov    0x8(%ebp),%eax\n  582   45a:	0f b6 00             	movzbl (%eax),%eax\n  583   45d:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  584:  460:	75 05                	jne    467 <strchr+0x1e>\n  585        return (char*)s;\n  586   462:	8b 45 08             	mov    0x8(%ebp),%eax\n  587:  465:	eb 13                	jmp    47a <strchr+0x31>\n  588  }\n  589  \n  590  char*\n  591: strchr(const char *s, char c)\n  592  {\n  593    for(; *s; s++)\n  ...\n  596   46e:	0f b6 00             	movzbl (%eax),%eax\n  597   471:	84 c0                	test   %al,%al\n  598:  473:	75 e2                	jne    457 <strchr+0xe>\n  599      if(*s == c)\n  600        return (char*)s;\n  ...\n  678  \n  679  int\n  680: stat(char *n, struct stat *st)\n  681  {\n  682   4ef:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/grep.c:\n   18      m += n;\n   19      p = buf;\n   20:     while((q = strchr(p, '\\n')) != 0){\n   21        *q = 0;\n   22        if(match(pattern, p)){\n   ..\n   74    if(re[0] == '^')\n   75      return matchhere(re+1, text);\n   76:   do{  // must look at empty string\n   77      if(matchhere(re, text))\n   78        return 1;\n\n/home/oron/os142/assignment1/grep.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 grep.c\n   ..\n   23  000009e1 morecore\n   24  00000000 \n   25: 00000389 strcpy\n   26  00000749 printf\n   27  00000588 memmove\n   ..\n   49  0000010a main\n   50  00000310 matchstar\n   51: 000003bd strcmp\n   52  00000644 dup\n   53  00000e60 buf\n   ..\n   59  000005cc exit\n   60  0000053d atoi\n   61: 000003fe strlen\n   62  0000060c open\n   63: 00000449 strchr\n   64  00000634 mkdir\n   65  000005f4 close\n\n/home/oron/os142/assignment1/ide.c:\n   24  // You must hold idelock while manipulating queue.\n   25  \n   26: static struct spinlock idelock;\n   27: static struct buf *idequeue;\n   28  \n   29  static int havedisk1;\n   30: static void idestart(struct buf*);\n   31  \n   32  // Wait for IDE disk to become ready.\n   ..\n   68  // Start the request for b.  Caller must hold idelock.\n   69  static void\n   70: idestart(struct buf *b)\n   71  {\n   72    if(b == 0)\n   ..\n   92  ideintr(void)\n   93  {\n   94:   struct buf *b;\n   95  \n   96    // First queued buffer is the active request.\n   ..\n  124  // Else if B_VALID is not set, read buf from disk, set B_VALID.\n  125  void\n  126: iderw(struct buf *b)\n  127  {\n  128:   struct buf **pp;\n  129  \n  130    if(!(b->flags & B_BUSY))\n\n/home/oron/os142/assignment1/init.asm:\n  148   138:	c3                   	ret    \n  149  \n  150: 00000139 <strcpy>:\n  151  #include \"user.h\"\n  152  #include \"x86.h\"\n  153  \n  154  char*\n  155: strcpy(char *s, char *t)\n  156  {\n  157   139:	55                   	push   %ebp\n  ...\n  176   160:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  177   164:	84 c0                	test   %al,%al\n  178:  166:	75 de                	jne    146 <strcpy+0xd>\n  179      ;\n  180    return os;\n  ...\n  184   16c:	c3                   	ret    \n  185  \n  186: 0000016d <strcmp>:\n  187  \n  188  int\n  189: strcmp(const char *p, const char *q)\n  190  {\n  191   16d:	55                   	push   %ebp\n  192   16e:	89 e5                	mov    %esp,%ebp\n  193    while(*p && *p == *q)\n  194:  170:	eb 08                	jmp    17a <strcmp+0xd>\n  195      p++, q++;\n  196   172:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  199  \n  200  int\n  201: strcmp(const char *p, const char *q)\n  202  {\n  203    while(*p && *p == *q)\n  ...\n  205   17d:	0f b6 00             	movzbl (%eax),%eax\n  206   180:	84 c0                	test   %al,%al\n  207:  182:	74 10                	je     194 <strcmp+0x27>\n  208   184:	8b 45 08             	mov    0x8(%ebp),%eax\n  209   187:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  211   18d:	0f b6 00             	movzbl (%eax),%eax\n  212   190:	38 c2                	cmp    %al,%dl\n  213:  192:	74 de                	je     172 <strcmp+0x5>\n  214      p++, q++;\n  215    return (uchar)*p - (uchar)*q;\n  ...\n  227   1ad:	c3                   	ret    \n  228  \n  229: 000001ae <strlen>:\n  230  \n  231  uint\n  232: strlen(char *s)\n  233  {\n  234   1ae:	55                   	push   %ebp\n  ...\n  239    for(n = 0; s[n]; n++)\n  240   1b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  241:  1bb:	eb 04                	jmp    1c1 <strlen+0x13>\n  242   1bd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  243   1c1:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  246   1c9:	0f b6 00             	movzbl (%eax),%eax\n  247   1cc:	84 c0                	test   %al,%al\n  248:  1ce:	75 ed                	jne    1bd <strlen+0xf>\n  249      ;\n  250    return n;\n  ...\n  276   1f8:	c3                   	ret    \n  277  \n  278: 000001f9 <strchr>:\n  279  \n  280  char*\n  281: strchr(const char *s, char c)\n  282  {\n  283   1f9:	55                   	push   %ebp\n  ...\n  287   202:	88 45 fc             	mov    %al,-0x4(%ebp)\n  288    for(; *s; s++)\n  289:  205:	eb 14                	jmp    21b <strchr+0x22>\n  290      if(*s == c)\n  291   207:	8b 45 08             	mov    0x8(%ebp),%eax\n  292   20a:	0f b6 00             	movzbl (%eax),%eax\n  293   20d:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  294:  210:	75 05                	jne    217 <strchr+0x1e>\n  295        return (char*)s;\n  296   212:	8b 45 08             	mov    0x8(%ebp),%eax\n  297:  215:	eb 13                	jmp    22a <strchr+0x31>\n  298  }\n  299  \n  300  char*\n  301: strchr(const char *s, char c)\n  302  {\n  303    for(; *s; s++)\n  ...\n  306   21e:	0f b6 00             	movzbl (%eax),%eax\n  307   221:	84 c0                	test   %al,%al\n  308:  223:	75 e2                	jne    207 <strchr+0xe>\n  309      if(*s == c)\n  310        return (char*)s;\n  ...\n  388  \n  389  int\n  390: stat(char *n, struct stat *st)\n  391  {\n  392   29f:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/init.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 init.c\n   ..\n   23  00000791 morecore\n   24  00000000 \n   25: 00000139 strcpy\n   26  000004f9 printf\n   27  00000b5c argv\n   ..\n   47  000001d5 memset\n   48  00000000 main\n   49: 0000016d strcmp\n   50  000003f4 dup\n   51  0000029f stat\n   ..\n   55  0000037c exit\n   56  000002ed atoi\n   57: 000001ae strlen\n   58  000003bc open\n   59: 000001f9 strchr\n   60  000003e4 mkdir\n   61  000003a4 close\n\n/home/oron/os142/assignment1/initcode.S:\n   22  # char init[] = \"/init\\0\";\n   23  init:\n   24:   .string \"/init\\0\"\n   25  \n   26  # char *argv[] = { init, 0 };\n\n/home/oron/os142/assignment1/ioapic.c:\n   23  #define INT_LOGICAL    0x00000800  // Destination is CPU id (vs APIC ID)\n   24  \n   25: volatile struct ioapic *ioapic;\n   26  \n   27: // IO APIC MMIO structure: write reg, then read or write data.\n   28: struct ioapic {\n   29    uint reg;\n   30    uint pad[3];\n   ..\n   54      return;\n   55  \n   56:   ioapic = (volatile struct ioapic*)IOAPIC;\n   57    maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;\n   58    id = ioapicread(REG_ID) >> 24;\n\n/home/oron/os142/assignment1/kalloc.c:\n   13  extern char end[]; // first address after kernel loaded from ELF file\n   14  \n   15: struct run {\n   16:   struct run *next;\n   17  };\n   18  \n   19: struct {\n   20:   struct spinlock lock;\n   21    int use_lock;\n   22:   struct run *freelist;\n   23  } kmem;\n   24  \n   ..\n   60  kfree(char *v)\n   61  {\n   62:   struct run *r;\n   63  \n   64    if((uint)v % PGSIZE || v < end || v2p(v) >= PHYSTOP)\n   ..\n   70    if(kmem.use_lock)\n   71      acquire(&kmem.lock);\n   72:   r = (struct run*)v;\n   73    r->next = kmem.freelist;\n   74    kmem.freelist = r;\n   ..\n   83  kalloc(void)\n   84  {\n   85:   struct run *r;\n   86  \n   87    if(kmem.use_lock)\n\n/home/oron/os142/assignment1/kernel.ld:\n   31  	}\n   32  \n   33: 	.stabstr : {\n   34: 		PROVIDE(__STABSTR_BEGIN__ = .);\n   35: 		*(.stabstr);\n   36: 		PROVIDE(__STABSTR_END__ = .);\n   37  		BYTE(0)		/* Force the linker to allocate space\n   38  				   for this section */\n\n/home/oron/os142/assignment1/kill.asm:\n   91    8c:	c3                   	ret    \n   92  \n   93: 0000008d <strcpy>:\n   94  #include \"user.h\"\n   95  #include \"x86.h\"\n   96  \n   97  char*\n   98: strcpy(char *s, char *t)\n   99  {\n  100    8d:	55                   	push   %ebp\n  ...\n  119    b4:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  120    b8:	84 c0                	test   %al,%al\n  121:   ba:	75 de                	jne    9a <strcpy+0xd>\n  122      ;\n  123    return os;\n  ...\n  127    c0:	c3                   	ret    \n  128  \n  129: 000000c1 <strcmp>:\n  130  \n  131  int\n  132: strcmp(const char *p, const char *q)\n  133  {\n  134    c1:	55                   	push   %ebp\n  135    c2:	89 e5                	mov    %esp,%ebp\n  136    while(*p && *p == *q)\n  137:   c4:	eb 08                	jmp    ce <strcmp+0xd>\n  138      p++, q++;\n  139    c6:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  142  \n  143  int\n  144: strcmp(const char *p, const char *q)\n  145  {\n  146    while(*p && *p == *q)\n  ...\n  148    d1:	0f b6 00             	movzbl (%eax),%eax\n  149    d4:	84 c0                	test   %al,%al\n  150:   d6:	74 10                	je     e8 <strcmp+0x27>\n  151    d8:	8b 45 08             	mov    0x8(%ebp),%eax\n  152    db:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  154    e1:	0f b6 00             	movzbl (%eax),%eax\n  155    e4:	38 c2                	cmp    %al,%dl\n  156:   e6:	74 de                	je     c6 <strcmp+0x5>\n  157      p++, q++;\n  158    return (uchar)*p - (uchar)*q;\n  ...\n  170   101:	c3                   	ret    \n  171  \n  172: 00000102 <strlen>:\n  173  \n  174  uint\n  175: strlen(char *s)\n  176  {\n  177   102:	55                   	push   %ebp\n  ...\n  182    for(n = 0; s[n]; n++)\n  183   108:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  184:  10f:	eb 04                	jmp    115 <strlen+0x13>\n  185   111:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  186   115:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  189   11d:	0f b6 00             	movzbl (%eax),%eax\n  190   120:	84 c0                	test   %al,%al\n  191:  122:	75 ed                	jne    111 <strlen+0xf>\n  192      ;\n  193    return n;\n  ...\n  219   14c:	c3                   	ret    \n  220  \n  221: 0000014d <strchr>:\n  222  \n  223  char*\n  224: strchr(const char *s, char c)\n  225  {\n  226   14d:	55                   	push   %ebp\n  ...\n  230   156:	88 45 fc             	mov    %al,-0x4(%ebp)\n  231    for(; *s; s++)\n  232:  159:	eb 14                	jmp    16f <strchr+0x22>\n  233      if(*s == c)\n  234   15b:	8b 45 08             	mov    0x8(%ebp),%eax\n  235   15e:	0f b6 00             	movzbl (%eax),%eax\n  236   161:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  237:  164:	75 05                	jne    16b <strchr+0x1e>\n  238        return (char*)s;\n  239   166:	8b 45 08             	mov    0x8(%ebp),%eax\n  240:  169:	eb 13                	jmp    17e <strchr+0x31>\n  241  }\n  242  \n  243  char*\n  244: strchr(const char *s, char c)\n  245  {\n  246    for(; *s; s++)\n  ...\n  249   172:	0f b6 00             	movzbl (%eax),%eax\n  250   175:	84 c0                	test   %al,%al\n  251:  177:	75 e2                	jne    15b <strchr+0xe>\n  252      if(*s == c)\n  253        return (char*)s;\n  ...\n  331  \n  332  int\n  333: stat(char *n, struct stat *st)\n  334  {\n  335   1f3:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/kill.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 kill.c\n   ..\n   23  000006e5 morecore\n   24  00000000 \n   25: 0000008d strcpy\n   26  0000044d printf\n   27  0000028c memmove\n   ..\n   46  00000129 memset\n   47  00000000 main\n   48: 000000c1 strcmp\n   49  00000348 dup\n   50  000001f3 stat\n   ..\n   54  000002d0 exit\n   55  00000241 atoi\n   56: 00000102 strlen\n   57  00000310 open\n   58: 0000014d strchr\n   59  00000338 mkdir\n   60  000002f8 close\n\n/home/oron/os142/assignment1/ln.asm:\n   90    a0:	c3                   	ret    \n   91  \n   92: 000000a1 <strcpy>:\n   93  #include \"user.h\"\n   94  #include \"x86.h\"\n   95  \n   96  char*\n   97: strcpy(char *s, char *t)\n   98  {\n   99    a1:	55                   	push   %ebp\n  ...\n  118    c8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  119    cc:	84 c0                	test   %al,%al\n  120:   ce:	75 de                	jne    ae <strcpy+0xd>\n  121      ;\n  122    return os;\n  ...\n  126    d4:	c3                   	ret    \n  127  \n  128: 000000d5 <strcmp>:\n  129  \n  130  int\n  131: strcmp(const char *p, const char *q)\n  132  {\n  133    d5:	55                   	push   %ebp\n  134    d6:	89 e5                	mov    %esp,%ebp\n  135    while(*p && *p == *q)\n  136:   d8:	eb 08                	jmp    e2 <strcmp+0xd>\n  137      p++, q++;\n  138    da:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  141  \n  142  int\n  143: strcmp(const char *p, const char *q)\n  144  {\n  145    while(*p && *p == *q)\n  ...\n  147    e5:	0f b6 00             	movzbl (%eax),%eax\n  148    e8:	84 c0                	test   %al,%al\n  149:   ea:	74 10                	je     fc <strcmp+0x27>\n  150    ec:	8b 45 08             	mov    0x8(%ebp),%eax\n  151    ef:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  153    f5:	0f b6 00             	movzbl (%eax),%eax\n  154    f8:	38 c2                	cmp    %al,%dl\n  155:   fa:	74 de                	je     da <strcmp+0x5>\n  156      p++, q++;\n  157    return (uchar)*p - (uchar)*q;\n  ...\n  169   115:	c3                   	ret    \n  170  \n  171: 00000116 <strlen>:\n  172  \n  173  uint\n  174: strlen(char *s)\n  175  {\n  176   116:	55                   	push   %ebp\n  ...\n  181    for(n = 0; s[n]; n++)\n  182   11c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  183:  123:	eb 04                	jmp    129 <strlen+0x13>\n  184   125:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  185   129:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  188   131:	0f b6 00             	movzbl (%eax),%eax\n  189   134:	84 c0                	test   %al,%al\n  190:  136:	75 ed                	jne    125 <strlen+0xf>\n  191      ;\n  192    return n;\n  ...\n  218   160:	c3                   	ret    \n  219  \n  220: 00000161 <strchr>:\n  221  \n  222  char*\n  223: strchr(const char *s, char c)\n  224  {\n  225   161:	55                   	push   %ebp\n  ...\n  229   16a:	88 45 fc             	mov    %al,-0x4(%ebp)\n  230    for(; *s; s++)\n  231:  16d:	eb 14                	jmp    183 <strchr+0x22>\n  232      if(*s == c)\n  233   16f:	8b 45 08             	mov    0x8(%ebp),%eax\n  234   172:	0f b6 00             	movzbl (%eax),%eax\n  235   175:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  236:  178:	75 05                	jne    17f <strchr+0x1e>\n  237        return (char*)s;\n  238   17a:	8b 45 08             	mov    0x8(%ebp),%eax\n  239:  17d:	eb 13                	jmp    192 <strchr+0x31>\n  240  }\n  241  \n  242  char*\n  243: strchr(const char *s, char c)\n  244  {\n  245    for(; *s; s++)\n  ...\n  248   186:	0f b6 00             	movzbl (%eax),%eax\n  249   189:	84 c0                	test   %al,%al\n  250:  18b:	75 e2                	jne    16f <strchr+0xe>\n  251      if(*s == c)\n  252        return (char*)s;\n  ...\n  330  \n  331  int\n  332: stat(char *n, struct stat *st)\n  333  {\n  334   207:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/ln.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 ln.c\n   ..\n   23  000006f9 morecore\n   24  00000000 \n   25: 000000a1 strcpy\n   26  00000461 printf\n   27  000002a0 memmove\n   ..\n   46  0000013d memset\n   47  00000000 main\n   48: 000000d5 strcmp\n   49  0000035c dup\n   50  00000207 stat\n   ..\n   54  000002e4 exit\n   55  00000255 atoi\n   56: 00000116 strlen\n   57  00000324 open\n   58: 00000161 strchr\n   59  0000034c mkdir\n   60  0000030c close\n\n/home/oron/os142/assignment1/log.c:\n   34  // Contents of the header block, used for both the on-disk header block\n   35  // and to keep track in memory of logged sector #s before commit.\n   36: struct logheader {\n   37    int n;   \n   38    int sector[LOGSIZE];\n   39  };\n   40  \n   41: struct log {\n   42:   struct spinlock lock;\n   43    int start;\n   44    int size;\n   45    int busy; // a transaction is active\n   46    int dev;\n   47:   struct logheader lh;\n   48  };\n   49: struct log log;\n   50  \n   51  static void recover_from_log(void);\n   ..\n   54  initlog(void)\n   55  {\n   56:   if (sizeof(struct logheader) >= BSIZE)\n   57      panic(\"initlog: too big logheader\");\n   58  \n   59:   struct superblock sb;\n   60    initlock(&log.lock, \"log\");\n   61    readsb(ROOTDEV, &sb);\n   ..\n   73  \n   74    for (tail = 0; tail < log.lh.n; tail++) {\n   75:     struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block\n   76:     struct buf *dbuf = bread(log.dev, log.lh.sector[tail]); // read dst\n   77      memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst\n   78      bwrite(dbuf);  // write dst to disk\n   ..\n   86  read_head(void)\n   87  {\n   88:   struct buf *buf = bread(log.dev, log.start);\n   89:   struct logheader *lh = (struct logheader *) (buf->data);\n   90    int i;\n   91    log.lh.n = lh->n;\n   ..\n  102  write_head(void)\n  103  {\n  104:   struct buf *buf = bread(log.dev, log.start);\n  105:   struct logheader *hb = (struct logheader *) (buf->data);\n  106    int i;\n  107    hb->n = log.lh.n;\n  ...\n  158  //   brelse(bp)\n  159  void\n  160: log_write(struct buf *b)\n  161  {\n  162    int i;\n  ...\n  172    }\n  173    log.lh.sector[i] = b->sector;\n  174:   struct buf *lbuf = bread(b->dev, log.start+i+1);\n  175    memmove(lbuf->data, b->data, BSIZE);\n  176    bwrite(lbuf);\n\n/home/oron/os142/assignment1/ls.asm:\n   20    \n   21    // Find first character after last slash.\n   22:   for(p=path+strlen(path); p >= path && *p != '/'; p--)\n   23     7:	8b 45 08             	mov    0x8(%ebp),%eax\n   24     a:	89 04 24             	mov    %eax,(%esp)\n   25:    d:	e8 e4 03 00 00       	call   3f6 <strlen>\n   26    12:	8b 55 08             	mov    0x8(%ebp),%edx\n   27    15:	01 d0                	add    %edx,%eax\n   ..\n   41    \n   42    // Return blank-padded name.\n   43:   if(strlen(p) >= DIRSIZ)\n   44    36:	8b 45 f4             	mov    -0xc(%ebp),%eax\n   45    39:	89 04 24             	mov    %eax,(%esp)\n   46:   3c:	e8 b5 03 00 00       	call   3f6 <strlen>\n   47    41:	83 f8 0d             	cmp    $0xd,%eax\n   48    44:	76 05                	jbe    4b <fmtname+0x4b>\n   ..\n   50    46:	8b 45 f4             	mov    -0xc(%ebp),%eax\n   51    49:	eb 5f                	jmp    aa <fmtname+0xaa>\n   52:   memmove(buf, p, strlen(p));\n   53    4b:	8b 45 f4             	mov    -0xc(%ebp),%eax\n   54    4e:	89 04 24             	mov    %eax,(%esp)\n   55:   51:	e8 a0 03 00 00       	call   3f6 <strlen>\n   56    56:	89 44 24 08          	mov    %eax,0x8(%esp)\n   57    5a:	8b 45 f4             	mov    -0xc(%ebp),%eax\n   ..\n   59    61:	c7 04 24 08 0e 00 00 	movl   $0xe08,(%esp)\n   60    68:	e8 13 05 00 00       	call   580 <memmove>\n   61:   memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));\n   62    6d:	8b 45 f4             	mov    -0xc(%ebp),%eax\n   63    70:	89 04 24             	mov    %eax,(%esp)\n   64:   73:	e8 7e 03 00 00       	call   3f6 <strlen>\n   65    78:	ba 0e 00 00 00       	mov    $0xe,%edx\n   66    7d:	89 d3                	mov    %edx,%ebx\n   ..\n   68    81:	8b 45 f4             	mov    -0xc(%ebp),%eax\n   69    84:	89 04 24             	mov    %eax,(%esp)\n   70:   87:	e8 6a 03 00 00       	call   3f6 <strlen>\n   71    8c:	05 08 0e 00 00       	add    $0xe08,%eax\n   72    91:	89 5c 24 08          	mov    %ebx,0x8(%esp)\n   ..\n   96    char buf[512], *p;\n   97    int fd;\n   98:   struct dirent de;\n   99:   struct stat st;\n  100    \n  101    if((fd = open(path, 0)) < 0){\n  ...\n  170    \n  171    case T_DIR:\n  172:     if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){\n  173   19c:	8b 45 08             	mov    0x8(%ebp),%eax\n  174   19f:	89 04 24             	mov    %eax,(%esp)\n  175:  1a2:	e8 4f 02 00 00       	call   3f6 <strlen>\n  176   1a7:	83 c0 10             	add    $0x10,%eax\n  177   1aa:	3d 00 02 00 00       	cmp    $0x200,%eax\n  ...\n  185   1c5:	e9 24 01 00 00       	jmp    2ee <ls+0x23e>\n  186      }\n  187:     strcpy(buf, path);\n  188   1ca:	8b 45 08             	mov    0x8(%ebp),%eax\n  189   1cd:	89 44 24 04          	mov    %eax,0x4(%esp)\n  190   1d1:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax\n  191   1d7:	89 04 24             	mov    %eax,(%esp)\n  192:  1da:	e8 a2 01 00 00       	call   381 <strcpy>\n  193:     p = buf+strlen(buf);\n  194   1df:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax\n  195   1e5:	89 04 24             	mov    %eax,(%esp)\n  196:  1e8:	e8 09 02 00 00       	call   3f6 <strlen>\n  197   1ed:	8d 95 e0 fd ff ff    	lea    -0x220(%ebp),%edx\n  198   1f3:	01 d0                	add    %edx,%eax\n  ...\n  257   2bf:	e8 7d 04 00 00       	call   741 <printf>\n  258   2c4:	eb 01                	jmp    2c7 <ls+0x217>\n  259:     strcpy(buf, path);\n  260:     p = buf+strlen(buf);\n  261      *p++ = '/';\n  262      while(read(fd, &de, sizeof(de)) == sizeof(de)){\n  ...\n  266        break;\n  267      }\n  268:     strcpy(buf, path);\n  269:     p = buf+strlen(buf);\n  270      *p++ = '/';\n  271      while(read(fd, &de, sizeof(de)) == sizeof(de)){\n  ...\n  379   380:	c3                   	ret    \n  380  \n  381: 00000381 <strcpy>:\n  382  #include \"user.h\"\n  383  #include \"x86.h\"\n  384  \n  385  char*\n  386: strcpy(char *s, char *t)\n  387  {\n  388   381:	55                   	push   %ebp\n  ...\n  407   3a8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  408   3ac:	84 c0                	test   %al,%al\n  409:  3ae:	75 de                	jne    38e <strcpy+0xd>\n  410      ;\n  411    return os;\n  ...\n  415   3b4:	c3                   	ret    \n  416  \n  417: 000003b5 <strcmp>:\n  418  \n  419  int\n  420: strcmp(const char *p, const char *q)\n  421  {\n  422   3b5:	55                   	push   %ebp\n  423   3b6:	89 e5                	mov    %esp,%ebp\n  424    while(*p && *p == *q)\n  425:  3b8:	eb 08                	jmp    3c2 <strcmp+0xd>\n  426      p++, q++;\n  427   3ba:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  430  \n  431  int\n  432: strcmp(const char *p, const char *q)\n  433  {\n  434    while(*p && *p == *q)\n  ...\n  436   3c5:	0f b6 00             	movzbl (%eax),%eax\n  437   3c8:	84 c0                	test   %al,%al\n  438:  3ca:	74 10                	je     3dc <strcmp+0x27>\n  439   3cc:	8b 45 08             	mov    0x8(%ebp),%eax\n  440   3cf:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  442   3d5:	0f b6 00             	movzbl (%eax),%eax\n  443   3d8:	38 c2                	cmp    %al,%dl\n  444:  3da:	74 de                	je     3ba <strcmp+0x5>\n  445      p++, q++;\n  446    return (uchar)*p - (uchar)*q;\n  ...\n  458   3f5:	c3                   	ret    \n  459  \n  460: 000003f6 <strlen>:\n  461  \n  462  uint\n  463: strlen(char *s)\n  464  {\n  465   3f6:	55                   	push   %ebp\n  ...\n  470    for(n = 0; s[n]; n++)\n  471   3fc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  472:  403:	eb 04                	jmp    409 <strlen+0x13>\n  473   405:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  474   409:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  477   411:	0f b6 00             	movzbl (%eax),%eax\n  478   414:	84 c0                	test   %al,%al\n  479:  416:	75 ed                	jne    405 <strlen+0xf>\n  480      ;\n  481    return n;\n  ...\n  507   440:	c3                   	ret    \n  508  \n  509: 00000441 <strchr>:\n  510  \n  511  char*\n  512: strchr(const char *s, char c)\n  513  {\n  514   441:	55                   	push   %ebp\n  ...\n  518   44a:	88 45 fc             	mov    %al,-0x4(%ebp)\n  519    for(; *s; s++)\n  520:  44d:	eb 14                	jmp    463 <strchr+0x22>\n  521      if(*s == c)\n  522   44f:	8b 45 08             	mov    0x8(%ebp),%eax\n  523   452:	0f b6 00             	movzbl (%eax),%eax\n  524   455:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  525:  458:	75 05                	jne    45f <strchr+0x1e>\n  526        return (char*)s;\n  527   45a:	8b 45 08             	mov    0x8(%ebp),%eax\n  528:  45d:	eb 13                	jmp    472 <strchr+0x31>\n  529  }\n  530  \n  531  char*\n  532: strchr(const char *s, char c)\n  533  {\n  534    for(; *s; s++)\n  ...\n  537   466:	0f b6 00             	movzbl (%eax),%eax\n  538   469:	84 c0                	test   %al,%al\n  539:  46b:	75 e2                	jne    44f <strchr+0xe>\n  540      if(*s == c)\n  541        return (char*)s;\n  ...\n  619  \n  620  int\n  621: stat(char *n, struct stat *st)\n  622  {\n  623   4e7:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/ls.c:\n   11    \n   12    // Find first character after last slash.\n   13:   for(p=path+strlen(path); p >= path && *p != '/'; p--)\n   14      ;\n   15    p++;\n   16    \n   17    // Return blank-padded name.\n   18:   if(strlen(p) >= DIRSIZ)\n   19      return p;\n   20:   memmove(buf, p, strlen(p));\n   21:   memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));\n   22    return buf;\n   23  }\n   ..\n   28    char buf[512], *p;\n   29    int fd;\n   30:   struct dirent de;\n   31:   struct stat st;\n   32    \n   33    if((fd = open(path, 0)) < 0){\n   ..\n   48    \n   49    case T_DIR:\n   50:     if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){\n   51        printf(1, \"ls: path too long\\n\");\n   52        break;\n   53      }\n   54:     strcpy(buf, path);\n   55:     p = buf+strlen(buf);\n   56      *p++ = '/';\n   57      while(read(fd, &de, sizeof(de)) == sizeof(de)){\n\n/home/oron/os142/assignment1/ls.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 ls.c\n   ..\n   24  000009d9 morecore\n   25  00000000 \n   26: 00000381 strcpy\n   27  00000000 fmtname\n   28  00000741 printf\n   ..\n   48  0000041d memset\n   49  00000304 main\n   50: 000003b5 strcmp\n   51  0000063c dup\n   52  000004e7 stat\n   ..\n   57  000005c4 exit\n   58  00000535 atoi\n   59: 000003f6 strlen\n   60  00000604 open\n   61: 00000441 strchr\n   62  0000062c mkdir\n   63  000005ec close\n\n/home/oron/os142/assignment1/main.c:\n   12  extern char end[]; // first address after kernel loaded from ELF file\n   13  \n   14: // Bootstrap processor starts running C code here.\n   15  // Allocate a real stack and switch to it, first\n   16  // doing some setup required for memory allocator to work.\n   ..\n   71    extern uchar _binary_entryother_start[], _binary_entryother_size[];\n   72    uchar *code;\n   73:   struct cpu *c;\n   74    char *stack;\n   75  \n\n/home/oron/os142/assignment1/memide.c:\n   35  // Else if B_VALID is not set, read buf from disk, set B_VALID.\n   36  void\n   37: iderw(struct buf *b)\n   38  {\n   39    uchar *p;\n\n/home/oron/os142/assignment1/mkdir.asm:\n  109    b4:	c3                   	ret    \n  110  \n  111: 000000b5 <strcpy>:\n  112  #include \"user.h\"\n  113  #include \"x86.h\"\n  114  \n  115  char*\n  116: strcpy(char *s, char *t)\n  117  {\n  118    b5:	55                   	push   %ebp\n  ...\n  137    dc:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  138    e0:	84 c0                	test   %al,%al\n  139:   e2:	75 de                	jne    c2 <strcpy+0xd>\n  140      ;\n  141    return os;\n  ...\n  145    e8:	c3                   	ret    \n  146  \n  147: 000000e9 <strcmp>:\n  148  \n  149  int\n  150: strcmp(const char *p, const char *q)\n  151  {\n  152    e9:	55                   	push   %ebp\n  153    ea:	89 e5                	mov    %esp,%ebp\n  154    while(*p && *p == *q)\n  155:   ec:	eb 08                	jmp    f6 <strcmp+0xd>\n  156      p++, q++;\n  157    ee:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  160  \n  161  int\n  162: strcmp(const char *p, const char *q)\n  163  {\n  164    while(*p && *p == *q)\n  ...\n  166    f9:	0f b6 00             	movzbl (%eax),%eax\n  167    fc:	84 c0                	test   %al,%al\n  168:   fe:	74 10                	je     110 <strcmp+0x27>\n  169   100:	8b 45 08             	mov    0x8(%ebp),%eax\n  170   103:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  172   109:	0f b6 00             	movzbl (%eax),%eax\n  173   10c:	38 c2                	cmp    %al,%dl\n  174:  10e:	74 de                	je     ee <strcmp+0x5>\n  175      p++, q++;\n  176    return (uchar)*p - (uchar)*q;\n  ...\n  188   129:	c3                   	ret    \n  189  \n  190: 0000012a <strlen>:\n  191  \n  192  uint\n  193: strlen(char *s)\n  194  {\n  195   12a:	55                   	push   %ebp\n  ...\n  200    for(n = 0; s[n]; n++)\n  201   130:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  202:  137:	eb 04                	jmp    13d <strlen+0x13>\n  203   139:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  204   13d:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  207   145:	0f b6 00             	movzbl (%eax),%eax\n  208   148:	84 c0                	test   %al,%al\n  209:  14a:	75 ed                	jne    139 <strlen+0xf>\n  210      ;\n  211    return n;\n  ...\n  237   174:	c3                   	ret    \n  238  \n  239: 00000175 <strchr>:\n  240  \n  241  char*\n  242: strchr(const char *s, char c)\n  243  {\n  244   175:	55                   	push   %ebp\n  ...\n  248   17e:	88 45 fc             	mov    %al,-0x4(%ebp)\n  249    for(; *s; s++)\n  250:  181:	eb 14                	jmp    197 <strchr+0x22>\n  251      if(*s == c)\n  252   183:	8b 45 08             	mov    0x8(%ebp),%eax\n  253   186:	0f b6 00             	movzbl (%eax),%eax\n  254   189:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  255:  18c:	75 05                	jne    193 <strchr+0x1e>\n  256        return (char*)s;\n  257   18e:	8b 45 08             	mov    0x8(%ebp),%eax\n  258:  191:	eb 13                	jmp    1a6 <strchr+0x31>\n  259  }\n  260  \n  261  char*\n  262: strchr(const char *s, char c)\n  263  {\n  264    for(; *s; s++)\n  ...\n  267   19a:	0f b6 00             	movzbl (%eax),%eax\n  268   19d:	84 c0                	test   %al,%al\n  269:  19f:	75 e2                	jne    183 <strchr+0xe>\n  270      if(*s == c)\n  271        return (char*)s;\n  ...\n  349  \n  350  int\n  351: stat(char *n, struct stat *st)\n  352  {\n  353   21b:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/mkdir.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 mkdir.c\n   ..\n   23  0000070d morecore\n   24  00000000 \n   25: 000000b5 strcpy\n   26  00000475 printf\n   27  000002b4 memmove\n   ..\n   46  00000151 memset\n   47  00000000 main\n   48: 000000e9 strcmp\n   49  00000370 dup\n   50  0000021b stat\n   ..\n   54  000002f8 exit\n   55  00000269 atoi\n   56: 0000012a strlen\n   57  00000338 open\n   58: 00000175 strchr\n   59  00000360 mkdir\n   60  00000320 close\n\n/home/oron/os142/assignment1/mkfs.c:\n    2  #include <unistd.h>\n    3  #include <stdlib.h>\n    4: #include <string.h>\n    5  #include <fcntl.h>\n    6  #include <assert.h>\n    7  \n    8: #define stat xv6_stat  // avoid clash with host struct stat\n    9  #include \"types.h\"\n   10  #include \"fs.h\"\n   ..\n   18  \n   19  int fsfd;\n   20: struct superblock sb;\n   21  char zeroes[512];\n   22  uint freeblock;\n   ..\n   27  void balloc(int);\n   28  void wsect(uint, void*);\n   29: void winode(uint, struct dinode*);\n   30: void rinode(uint inum, struct dinode *ip);\n   31  void rsect(uint sec, void *buf);\n   32  uint ialloc(ushort type);\n   ..\n   61    int i, cc, fd;\n   62    uint rootino, inum, off;\n   63:   struct dirent de;\n   64    char buf[512];\n   65:   struct dinode din;\n   66  \n   67    if(argc < 2){\n   ..\n   70    }\n   71  \n   72:   assert((512 % sizeof(struct dinode)) == 0);\n   73:   assert((512 % sizeof(struct dirent)) == 0);\n   74  \n   75    fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);\n   ..\n  105    bzero(&de, sizeof(de));\n  106    de.inum = xshort(rootino);\n  107:   strcpy(de.name, \".\");\n  108    iappend(rootino, &de, sizeof(de));\n  109  \n  110    bzero(&de, sizeof(de));\n  111    de.inum = xshort(rootino);\n  112:   strcpy(de.name, \"..\");\n  113    iappend(rootino, &de, sizeof(de));\n  114  \n  ...\n  132      bzero(&de, sizeof(de));\n  133      de.inum = xshort(inum);\n  134:     strncpy(de.name, argv[i], DIRSIZ);\n  135      iappend(rootino, &de, sizeof(de));\n  136  \n  ...\n  173  \n  174  void\n  175: winode(uint inum, struct dinode *ip)\n  176  {\n  177    char buf[512];\n  178    uint bn;\n  179:   struct dinode *dip;\n  180  \n  181    bn = i2b(inum);\n  182    rsect(bn, buf);\n  183:   dip = ((struct dinode*)buf) + (inum % IPB);\n  184    *dip = *ip;\n  185    wsect(bn, buf);\n  ...\n  187  \n  188  void\n  189: rinode(uint inum, struct dinode *ip)\n  190  {\n  191    char buf[512];\n  192    uint bn;\n  193:   struct dinode *dip;\n  194  \n  195    bn = i2b(inum);\n  196    rsect(bn, buf);\n  197:   dip = ((struct dinode*)buf) + (inum % IPB);\n  198    *ip = *dip;\n  199  }\n  ...\n  216  {\n  217    uint inum = freeinode++;\n  218:   struct dinode din;\n  219  \n  220    bzero(&din, sizeof(din));\n  ...\n  249    char *p = (char*)xp;\n  250    uint fbn, off, n1;\n  251:   struct dinode din;\n  252    char buf[512];\n  253    uint indirect[NINDIRECT];\n\n/home/oron/os142/assignment1/mmu.h:\n   50  #ifndef __ASSEMBLER__\n   51  // Segment Descriptor\n   52: struct segdesc {\n   53    uint lim_15_0 : 16;  // Low bits of segment limit\n   54    uint base_15_0 : 16; // Low bits of segment base address\n   ..\n   67  \n   68  // Normal segment\n   69: #define SEG(type, base, lim, dpl) (struct segdesc)    \\\n   70  { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \\\n   71    ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \\\n   72    (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }\n   73: #define SEG16(type, base, lim, dpl) (struct segdesc)  \\\n   74  { (lim) & 0xffff, (uint)(base) & 0xffff,              \\\n   75    ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \\\n   ..\n  101  #define STS_TG32    0xF     // 32-bit Trap Gate\n  102  \n  103: // A virtual address 'la' has a three-part structure as follows:\n  104  //\n  105  // +--------10------+-------10-------+---------12----------+\n  ...\n  115  #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)\n  116  \n  117: // construct virtual address from indexes and offset\n  118  #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))\n  119  \n  ...\n  148  \n  149  // Task state segment format\n  150: struct taskstate {\n  151    uint link;         // Old ts selector\n  152    uint esp0;         // Stack pointers and segment selectors\n  ...\n  190  // PAGEBREAK: 12\n  191  // Gate descriptors for interrupts and traps\n  192: struct gatedesc {\n  193    uint off_15_0 : 16;   // low 16 bits of offset in segment\n  194    uint cs : 16;         // code segment selector\n  ...\n  203  \n  204  // Set up a normal interrupt/trap gate descriptor.\n  205: // - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.\n  206  //   interrupt gate clears FL_IF, trap gate leaves FL_IF alone\n  207  // - sel: Code segment selector for interrupt/trap handler\n  ...\n  209  // - dpl: Descriptor Privilege Level -\n  210  //        the privilege level required for software to invoke\n  211: //        this interrupt/trap gate explicitly using an int instruction.\n  212: #define SETGATE(gate, istrap, sel, off, d)                \\\n  213  {                                                         \\\n  214    (gate).off_15_0 = (uint)(off) & 0xffff;                \\\n  ...\n  216    (gate).args = 0;                                        \\\n  217    (gate).rsv1 = 0;                                        \\\n  218:   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \\\n  219    (gate).s = 0;                                           \\\n  220    (gate).dpl = (d);                                       \\\n\n/home/oron/os142/assignment1/mp.c:\n    1  // Multiprocessor support\n    2: // Search memory for MP description structures.\n    3  // http://developer.intel.com/design/pentium/datashts/24201606.pdf\n    4  \n    .\n   12  #include \"proc.h\"\n   13  \n   14: struct cpu cpus[NCPU];\n   15: static struct cpu *bcpu;\n   16  int ismp;\n   17  int ncpu;\n   ..\n   35  }\n   36  \n   37: // Look for an MP structure in the len bytes at addr.\n   38: static struct mp*\n   39  mpsearch1(uint a, int len)\n   40  {\n   ..\n   43    addr = p2v(a);\n   44    e = addr+len;\n   45:   for(p = addr; p < e; p += sizeof(struct mp))\n   46:     if(memcmp(p, \"_MP_\", 4) == 0 && sum(p, sizeof(struct mp)) == 0)\n   47:       return (struct mp*)p;\n   48    return 0;\n   49  }\n   50  \n   51: // Search for the MP Floating Pointer Structure, which according to the\n   52  // spec is in one of the following three locations:\n   53  // 1) in the first KB of the EBDA;\n   54  // 2) in the last KB of system base memory;\n   55  // 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.\n   56: static struct mp*\n   57  mpsearch(void)\n   58  {\n   59    uchar *bda;\n   60    uint p;\n   61:   struct mp *mp;\n   62  \n   63    bda = (uchar *) P2V(0x400);\n   ..\n   78  // if correct, check the version.\n   79  // To do: check extended table checksum.\n   80: static struct mpconf*\n   81: mpconfig(struct mp **pmp)\n   82  {\n   83:   struct mpconf *conf;\n   84:   struct mp *mp;\n   85  \n   86    if((mp = mpsearch()) == 0 || mp->physaddr == 0)\n   87      return 0;\n   88:   conf = (struct mpconf*) p2v((uint) mp->physaddr);\n   89    if(memcmp(conf, \"PCMP\", 4) != 0)\n   90      return 0;\n   ..\n  101  {\n  102    uchar *p, *e;\n  103:   struct mp *mp;\n  104:   struct mpconf *conf;\n  105:   struct mpproc *proc;\n  106:   struct mpioapic *ioapic;\n  107  \n  108    bcpu = &cpus[0];\n  ...\n  114      switch(*p){\n  115      case MPPROC:\n  116:       proc = (struct mpproc*)p;\n  117        if(ncpu != proc->apicid){\n  118          cprintf(\"mpinit: ncpu=%d apicid=%d\\n\", ncpu, proc->apicid);\n  ...\n  123        cpus[ncpu].id = ncpu;\n  124        ncpu++;\n  125:       p += sizeof(struct mpproc);\n  126        continue;\n  127      case MPIOAPIC:\n  128:       ioapic = (struct mpioapic*)p;\n  129        ioapicid = ioapic->apicno;\n  130:       p += sizeof(struct mpioapic);\n  131        continue;\n  132      case MPBUS:\n\n/home/oron/os142/assignment1/mp.h:\n    1  // See MultiProcessor Specification Version 1.[14]\n    2  \n    3: struct mp {             // floating pointer\n    4    uchar signature[4];           // \"_MP_\"\n    5    void *physaddr;               // phys addr of MP config table\n    .\n   12  };\n   13  \n   14: struct mpconf {         // configuration table header\n   15    uchar signature[4];           // \"PCMP\"\n   16    ushort length;                // total table length\n   ..\n   27  };\n   28  \n   29: struct mpproc {         // processor table entry\n   30    uchar type;                   // entry type (0)\n   31    uchar apicid;                 // local APIC id\n   32    uchar version;                // local APIC verison\n   33    uchar flags;                  // CPU flags\n   34:     #define MPBOOT 0x02           // This proc is the bootstrap processor.\n   35    uchar signature[4];           // CPU signature\n   36:   uint feature;                 // feature flags from CPUID instruction\n   37    uchar reserved[8];\n   38  };\n   39  \n   40: struct mpioapic {       // I/O APIC table entry\n   41    uchar type;                   // entry type (2)\n   42    uchar apicno;                 // I/O APIC id\n\n/home/oron/os142/assignment1/pipe.c:\n   10  #define PIPESIZE 512\n   11  \n   12: struct pipe {\n   13:   struct spinlock lock;\n   14    char data[PIPESIZE];\n   15    uint nread;     // number of bytes read\n   ..\n   20  \n   21  int\n   22: pipealloc(struct file **f0, struct file **f1)\n   23  {\n   24:   struct pipe *p;\n   25  \n   26    p = 0;\n   ..\n   28    if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)\n   29      goto bad;\n   30:   if((p = (struct pipe*)kalloc()) == 0)\n   31      goto bad;\n   32    p->readopen = 1;\n   ..\n   57  \n   58  void\n   59: pipeclose(struct pipe *p, int writable)\n   60  {\n   61    acquire(&p->lock);\n   ..\n   76  //PAGEBREAK: 40\n   77  int\n   78: pipewrite(struct pipe *p, char *addr, int n)\n   79  {\n   80    int i;\n   ..\n   98  \n   99  int\n  100: piperead(struct pipe *p, char *addr, int n)\n  101  {\n  102    int i;\n\n/home/oron/os142/assignment1/pr.pl:\n    1  #!/usr/bin/perl\n    2  \n    3: use POSIX qw(strftime);\n    4  \n    5  if($ARGV[0] eq \"-h\"){\n    .\n   12  \n   13  $page = 0;\n   14: $now = strftime \"%b %e %H:%M %Y\", localtime;\n   15  \n   16  @lines = <>;\n\n/home/oron/os142/assignment1/proc.c:\n    8  #include \"spinlock.h\"\n    9  \n   10: struct {\n   11:   struct spinlock lock;\n   12:   struct proc proc[NPROC];\n   13  } ptable;\n   14  \n   15: static struct proc *initproc;\n   16  \n   17  int nextpid = 1;\n   ..\n   32  // state required to run in the kernel.\n   33  // Otherwise return 0.\n   34: static struct proc*\n   35  allocproc(void)\n   36  {\n   37:   struct proc *p;\n   38    char *sp;\n   39  \n   ..\n   59    // Leave room for trap frame.\n   60    sp -= sizeof *p->tf;\n   61:   p->tf = (struct trapframe*)sp;\n   62    \n   63    // Set up new context to start executing at forkret,\n   ..\n   67  \n   68    sp -= sizeof *p->context;\n   69:   p->context = (struct context*)sp;\n   70    memset(p->context, 0, sizeof *p->context);\n   71    p->context->eip = (uint)forkret;\n   ..\n   79  userinit(void)\n   80  {\n   81:   struct proc *p;\n   82    extern char _binary_initcode_start[], _binary_initcode_size[];\n   83    \n   ..\n   97    p->tf->eip = 0;  // beginning of initcode.S\n   98  \n   99:   safestrcpy(p->name, \"initcode\", sizeof(p->name));\n  100    p->cwd = namei(\"/\");\n  101  \n  ...\n  130  {\n  131    int i, pid;\n  132:   struct proc *np;\n  133  \n  134    // Allocate process.\n  ...\n  157    pid = np->pid;\n  158    np->state = RUNNABLE;\n  159:   safestrcpy(np->name, proc->name, sizeof(proc->name));\n  160    return pid;\n  161  }\n  ...\n  167  exit(void)\n  168  {\n  169:   struct proc *p;\n  170    int fd;\n  171  \n  ...\n  209  wait(void)\n  210  {\n  211:   struct proc *p;\n  212    int havekids, pid;\n  213  \n  ...\n  275  scheduler(void)\n  276  {\n  277:   struct proc *p;\n  278  \n  279    for(;;){\n  ...\n  358  // Reacquires lock when awakened.\n  359  void\n  360: sleep(void *chan, struct spinlock *lk)\n  361  {\n  362    if(proc == 0)\n  ...\n  398  wakeup1(void *chan)\n  399  {\n  400:   struct proc *p;\n  401  \n  402    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)\n  ...\n  420  kill(int pid)\n  421  {\n  422:   struct proc *p;\n  423  \n  424    acquire(&ptable.lock);\n  ...\n  453    };\n  454    int i;\n  455:   struct proc *p;\n  456    char *state;\n  457    uint pc[10];\n\n/home/oron/os142/assignment1/proc.h:\n    3  \n    4  // Per-CPU state\n    5: struct cpu {\n    6    uchar id;                    // Local APIC ID; index into cpus[] below\n    7:   struct context *scheduler;   // swtch() here to enter scheduler\n    8:   struct taskstate ts;         // Used by x86 to find stack for interrupt\n    9:   struct segdesc gdt[NSEGS];   // x86 global descriptor table\n   10    volatile uint started;        // Has the CPU started?\n   11    int ncli;                    // Depth of pushcli nesting.\n   ..\n   13    \n   14    // Cpu-local storage variables; see below\n   15:   struct cpu *cpu;\n   16:   struct proc *proc;           // The currently-running process.\n   17  };\n   18  \n   19: extern struct cpu cpus[NCPU];\n   20  extern int ncpu;\n   21  \n   ..\n   25  // and \"%gs:4\" to refer to proc.  seginit sets up the\n   26  // %gs segment register so that %gs refers to the memory\n   27: // holding those two variables in the local cpu's struct cpu.\n   28  // This is similar to how thread-local variables are implemented\n   29  // in thread libraries such as Linux pthreads.\n   30: extern struct cpu *cpu asm(\"%gs:0\");       // &cpus[cpunum()]\n   31: extern struct proc *proc asm(\"%gs:4\");     // cpus[cpunum()].proc\n   32  \n   33  //PAGEBREAK: 17\n   ..\n   42  // at the \"Switch stacks\" comment. Switch doesn't save eip explicitly,\n   43  // but it is on the stack and allocproc() manipulates it.\n   44: struct context {\n   45    uint edi;\n   46    uint esi;\n   ..\n   55  \n   56  // Per-process state\n   57: struct proc {\n   58    uint sz;                     // Size of process memory (bytes)\n   59    pde_t* pgdir;                // Page table\n   ..\n   61    enum procstate state;        // Process state\n   62    volatile int pid;            // Process ID\n   63:   struct proc *parent;         // Parent process\n   64:   struct trapframe *tf;        // Trap frame for current syscall\n   65:   struct context *context;     // swtch() here to run process\n   66    void *chan;                  // If non-zero, sleeping on chan\n   67    int killed;                  // If non-zero, have been killed\n   68:   struct file *ofile[NOFILE];  // Open files\n   69:   struct inode *cwd;           // Current directory\n   70    char name[16];               // Process name (debugging)\n   71  };\n\n/home/oron/os142/assignment1/question1.sublime-workspace:\n   46  		\"height\": 139.0\n   47  	},\n   48: 	\"distraction_free\":\n   49  	{\n   50  		\"menu_visible\": true,\n\n/home/oron/os142/assignment1/rm.asm:\n  109    b4:	c3                   	ret    \n  110  \n  111: 000000b5 <strcpy>:\n  112  #include \"user.h\"\n  113  #include \"x86.h\"\n  114  \n  115  char*\n  116: strcpy(char *s, char *t)\n  117  {\n  118    b5:	55                   	push   %ebp\n  ...\n  137    dc:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  138    e0:	84 c0                	test   %al,%al\n  139:   e2:	75 de                	jne    c2 <strcpy+0xd>\n  140      ;\n  141    return os;\n  ...\n  145    e8:	c3                   	ret    \n  146  \n  147: 000000e9 <strcmp>:\n  148  \n  149  int\n  150: strcmp(const char *p, const char *q)\n  151  {\n  152    e9:	55                   	push   %ebp\n  153    ea:	89 e5                	mov    %esp,%ebp\n  154    while(*p && *p == *q)\n  155:   ec:	eb 08                	jmp    f6 <strcmp+0xd>\n  156      p++, q++;\n  157    ee:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  160  \n  161  int\n  162: strcmp(const char *p, const char *q)\n  163  {\n  164    while(*p && *p == *q)\n  ...\n  166    f9:	0f b6 00             	movzbl (%eax),%eax\n  167    fc:	84 c0                	test   %al,%al\n  168:   fe:	74 10                	je     110 <strcmp+0x27>\n  169   100:	8b 45 08             	mov    0x8(%ebp),%eax\n  170   103:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  172   109:	0f b6 00             	movzbl (%eax),%eax\n  173   10c:	38 c2                	cmp    %al,%dl\n  174:  10e:	74 de                	je     ee <strcmp+0x5>\n  175      p++, q++;\n  176    return (uchar)*p - (uchar)*q;\n  ...\n  188   129:	c3                   	ret    \n  189  \n  190: 0000012a <strlen>:\n  191  \n  192  uint\n  193: strlen(char *s)\n  194  {\n  195   12a:	55                   	push   %ebp\n  ...\n  200    for(n = 0; s[n]; n++)\n  201   130:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  202:  137:	eb 04                	jmp    13d <strlen+0x13>\n  203   139:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  204   13d:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  207   145:	0f b6 00             	movzbl (%eax),%eax\n  208   148:	84 c0                	test   %al,%al\n  209:  14a:	75 ed                	jne    139 <strlen+0xf>\n  210      ;\n  211    return n;\n  ...\n  237   174:	c3                   	ret    \n  238  \n  239: 00000175 <strchr>:\n  240  \n  241  char*\n  242: strchr(const char *s, char c)\n  243  {\n  244   175:	55                   	push   %ebp\n  ...\n  248   17e:	88 45 fc             	mov    %al,-0x4(%ebp)\n  249    for(; *s; s++)\n  250:  181:	eb 14                	jmp    197 <strchr+0x22>\n  251      if(*s == c)\n  252   183:	8b 45 08             	mov    0x8(%ebp),%eax\n  253   186:	0f b6 00             	movzbl (%eax),%eax\n  254   189:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  255:  18c:	75 05                	jne    193 <strchr+0x1e>\n  256        return (char*)s;\n  257   18e:	8b 45 08             	mov    0x8(%ebp),%eax\n  258:  191:	eb 13                	jmp    1a6 <strchr+0x31>\n  259  }\n  260  \n  261  char*\n  262: strchr(const char *s, char c)\n  263  {\n  264    for(; *s; s++)\n  ...\n  267   19a:	0f b6 00             	movzbl (%eax),%eax\n  268   19d:	84 c0                	test   %al,%al\n  269:  19f:	75 e2                	jne    183 <strchr+0xe>\n  270      if(*s == c)\n  271        return (char*)s;\n  ...\n  349  \n  350  int\n  351: stat(char *n, struct stat *st)\n  352  {\n  353   21b:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/rm.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 rm.c\n   ..\n   23  0000070d morecore\n   24  00000000 \n   25: 000000b5 strcpy\n   26  00000475 printf\n   27  000002b4 memmove\n   ..\n   46  00000151 memset\n   47  00000000 main\n   48: 000000e9 strcmp\n   49  00000370 dup\n   50  0000021b stat\n   ..\n   54  000002f8 exit\n   55  00000269 atoi\n   56: 0000012a strlen\n   57  00000338 open\n   58: 00000175 strchr\n   59  00000360 mkdir\n   60  00000320 close\n\n/home/oron/os142/assignment1/runoff:\n  130  			next;\n  131  		}\n  132: 		if (/^[0-9]+ struct [a-zA-Z0-9_]+;/) {\n  133  			next;\n  134  		}\n  ...\n  154  		}\n  155  \n  156: 		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {\n  157  			print \"$1 $7\\n\";\n  158  		}\n  159  		\n  160: 		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ \n  161  			print \"$1 $3\\n\";\n  162  		}\n\n/home/oron/os142/assignment1/runoff.list:\n   51  pipe.c\n   52  \n   53: # string operations\n   54: string.c\n   55  \n   56  # low-level hardware\n\n/home/oron/os142/assignment1/runoff.spec:\n   32  even: spinlock.h\n   33  \n   34: # This gets struct proc and allocproc on the same spread\n   35  left: proc.h\n   36  even: proc.h\n   ..\n   93  \n   94  # even: pipe.c  # mild preference\n   95: # string.c either\n   96  # left: kbd.h  # mild preference\n   97  even: kbd.h\n\n/home/oron/os142/assignment1/sh.asm:\n    6  \n    7  00000000 <runcmd>:\n    8: struct cmd *parsecmd(char*);\n    9  \n   10  // Execute cmd.  Never returns.\n   11  void\n   12: runcmd(struct cmd *cmd)\n   13  {\n   14         0:	55                   	push   %ebp\n   15         1:	89 e5                	mov    %esp,%ebp\n   16         3:	83 ec 38             	sub    $0x38,%esp\n   17:   struct execcmd *ecmd;\n   18:   struct listcmd *lcmd;\n   19:   struct pipecmd *pcmd;\n   20:   struct redircmd *rcmd;\n   21  \n   22    if(cmd == 0)\n   ..\n   39  \n   40    case EXEC:\n   41:     ecmd = (struct execcmd*)cmd;\n   42        30:	8b 45 08             	mov    0x8(%ebp),%eax\n   43        33:	89 45 f4             	mov    %eax,-0xc(%ebp)\n   ..\n   69  \n   70    case REDIR:\n   71:     rcmd = (struct redircmd*)cmd;\n   72        80:	8b 45 08             	mov    0x8(%ebp),%eax\n   73        83:	89 45 f0             	mov    %eax,-0x10(%ebp)\n   ..\n  107  \n  108    case LIST:\n  109:     lcmd = (struct listcmd*)cmd;\n  110        e6:	8b 45 08             	mov    0x8(%ebp),%eax\n  111        e9:	89 45 ec             	mov    %eax,-0x14(%ebp)\n  ...\n  130  \n  131    case PIPE:\n  132:     pcmd = (struct pipecmd*)cmd;\n  133       11b:	8b 45 08             	mov    0x8(%ebp),%eax\n  134       11e:	89 45 e8             	mov    %eax,-0x18(%ebp)\n  ...\n  208      \n  209    case BACK:\n  210:     bcmd = (struct backcmd*)cmd;\n  211       1e6:	8b 45 08             	mov    0x8(%ebp),%eax\n  212       1e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)\n  ...\n  330        // Clumsy but will have to do for now.\n  331        // Chdir has no effect on the parent if run in the child.\n  332:       buf[strlen(buf)-1] = 0;  // chop \\n\n  333       2d0:	c7 04 24 60 1a 00 00 	movl   $0x1a60,(%esp)\n  334:      2d7:	e8 ba 0a 00 00       	call   d96 <strlen>\n  335       2dc:	83 e8 01             	sub    $0x1,%eax\n  336       2df:	c6 80 60 1a 00 00 00 	movb   $0x0,0x1a60(%eax)\n  ...\n  364        // Clumsy but will have to do for now.\n  365        // Chdir has no effect on the parent if run in the child.\n  366:       buf[strlen(buf)-1] = 0;  // chop \\n\n  367        if(chdir(buf+3) < 0)\n  368          printf(2, \"cannot cd %s\\n\", buf+3);\n  ...\n  436  000003a5 <execcmd>:\n  437  //PAGEBREAK!\n  438: // Constructors\n  439  \n  440: struct cmd*\n  441  execcmd(void)\n  442  {\n  ...\n  444       3a6:	89 e5                	mov    %esp,%ebp\n  445       3a8:	83 ec 28             	sub    $0x28,%esp\n  446:   struct execcmd *cmd;\n  447  \n  448    cmd = malloc(sizeof(*cmd));\n  ...\n  461       3d5:	8b 45 f4             	mov    -0xc(%ebp),%eax\n  462       3d8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)\n  463:   return (struct cmd*)cmd;\n  464       3de:	8b 45 f4             	mov    -0xc(%ebp),%eax\n  465  }\n  ...\n  469  000003e3 <redircmd>:\n  470  \n  471: struct cmd*\n  472: redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)\n  473  {\n  474       3e3:	55                   	push   %ebp\n  475       3e4:	89 e5                	mov    %esp,%ebp\n  476       3e6:	83 ec 28             	sub    $0x28,%esp\n  477:   struct redircmd *cmd;\n  478  \n  479    cmd = malloc(sizeof(*cmd));\n  ...\n  512       443:	8b 55 18             	mov    0x18(%ebp),%edx\n  513       446:	89 50 14             	mov    %edx,0x14(%eax)\n  514:   return (struct cmd*)cmd;\n  515       449:	8b 45 f4             	mov    -0xc(%ebp),%eax\n  516  }\n  ...\n  520  0000044e <pipecmd>:\n  521  \n  522: struct cmd*\n  523: pipecmd(struct cmd *left, struct cmd *right)\n  524  {\n  525       44e:	55                   	push   %ebp\n  526       44f:	89 e5                	mov    %esp,%ebp\n  527       451:	83 ec 28             	sub    $0x28,%esp\n  528:   struct pipecmd *cmd;\n  529  \n  530    cmd = malloc(sizeof(*cmd));\n  ...\n  551       493:	8b 55 0c             	mov    0xc(%ebp),%edx\n  552       496:	89 50 08             	mov    %edx,0x8(%eax)\n  553:   return (struct cmd*)cmd;\n  554       499:	8b 45 f4             	mov    -0xc(%ebp),%eax\n  555  }\n  ...\n  559  0000049e <listcmd>:\n  560  \n  561: struct cmd*\n  562: listcmd(struct cmd *left, struct cmd *right)\n  563  {\n  564       49e:	55                   	push   %ebp\n  565       49f:	89 e5                	mov    %esp,%ebp\n  566       4a1:	83 ec 28             	sub    $0x28,%esp\n  567:   struct listcmd *cmd;\n  568  \n  569    cmd = malloc(sizeof(*cmd));\n  ...\n  590       4e3:	8b 55 0c             	mov    0xc(%ebp),%edx\n  591       4e6:	89 50 08             	mov    %edx,0x8(%eax)\n  592:   return (struct cmd*)cmd;\n  593       4e9:	8b 45 f4             	mov    -0xc(%ebp),%eax\n  594  }\n  ...\n  598  000004ee <backcmd>:\n  599  \n  600: struct cmd*\n  601: backcmd(struct cmd *subcmd)\n  602  {\n  603       4ee:	55                   	push   %ebp\n  604       4ef:	89 e5                	mov    %esp,%ebp\n  605       4f1:	83 ec 28             	sub    $0x28,%esp\n  606:   struct backcmd *cmd;\n  607  \n  608    cmd = malloc(sizeof(*cmd));\n  ...\n  625       52a:	8b 55 08             	mov    0x8(%ebp),%edx\n  626       52d:	89 50 04             	mov    %edx,0x4(%eax)\n  627:   return (struct cmd*)cmd;\n  628       530:	8b 45 f4             	mov    -0xc(%ebp),%eax\n  629  }\n  ...\n  648       53e:	8b 00                	mov    (%eax),%eax\n  649       540:	89 45 f4             	mov    %eax,-0xc(%ebp)\n  650:   while(s < es && strchr(whitespace, *s))\n  651       543:	eb 04                	jmp    549 <gettoken+0x14>\n  652      s++;\n  ...\n  657    \n  658    s = *ps;\n  659:   while(s < es && strchr(whitespace, *s))\n  660       549:	8b 45 f4             	mov    -0xc(%ebp),%eax\n  661       54c:	3b 45 0c             	cmp    0xc(%ebp),%eax\n  ...\n  666       55a:	89 44 24 04          	mov    %eax,0x4(%esp)\n  667       55e:	c7 04 24 24 1a 00 00 	movl   $0x1a24,(%esp)\n  668:      565:	e8 77 08 00 00       	call   de1 <strchr>\n  669       56a:	85 c0                	test   %eax,%eax\n  670       56c:	75 d7                	jne    545 <gettoken+0x10>\n  ...\n  730      ret = 'a';\n  731       5df:	c7 45 f0 61 00 00 00 	movl   $0x61,-0x10(%ebp)\n  732:     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))\n  733       5e6:	eb 04                	jmp    5ec <gettoken+0xb7>\n  734        s++;\n  ...\n  739    default:\n  740      ret = 'a';\n  741:     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))\n  742       5ec:	8b 45 f4             	mov    -0xc(%ebp),%eax\n  743       5ef:	3b 45 0c             	cmp    0xc(%ebp),%eax\n  ...\n  748       5fd:	89 44 24 04          	mov    %eax,0x4(%esp)\n  749       601:	c7 04 24 24 1a 00 00 	movl   $0x1a24,(%esp)\n  750:      608:	e8 d4 07 00 00       	call   de1 <strchr>\n  751       60d:	85 c0                	test   %eax,%eax\n  752       60f:	75 25                	jne    636 <gettoken+0x101>\n  ...\n  756       61a:	89 44 24 04          	mov    %eax,0x4(%esp)\n  757       61e:	c7 04 24 2a 1a 00 00 	movl   $0x1a2a,(%esp)\n  758:      625:	e8 b7 07 00 00       	call   de1 <strchr>\n  759       62a:	85 c0                	test   %eax,%eax\n  760       62c:	74 ba                	je     5e8 <gettoken+0xb3>\n  ...\n  780    default:\n  781      ret = 'a';\n  782:     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))\n  783        s++;\n  784      break;\n  ...\n  793       643:	89 10                	mov    %edx,(%eax)\n  794    \n  795:   while(s < es && strchr(whitespace, *s))\n  796       645:	eb 04                	jmp    64b <gettoken+0x116>\n  797      s++;\n  ...\n  802      *eq = s;\n  803    \n  804:   while(s < es && strchr(whitespace, *s))\n  805       64b:	8b 45 f4             	mov    -0xc(%ebp),%eax\n  806       64e:	3b 45 0c             	cmp    0xc(%ebp),%eax\n  ...\n  811       65c:	89 44 24 04          	mov    %eax,0x4(%esp)\n  812       660:	c7 04 24 24 1a 00 00 	movl   $0x1a24,(%esp)\n  813:      667:	e8 75 07 00 00       	call   de1 <strchr>\n  814       66c:	85 c0                	test   %eax,%eax\n  815       66e:	75 d7                	jne    647 <gettoken+0x112>\n  ...\n  839       686:	8b 00                	mov    (%eax),%eax\n  840       688:	89 45 f4             	mov    %eax,-0xc(%ebp)\n  841:   while(s < es && strchr(whitespace, *s))\n  842       68b:	eb 04                	jmp    691 <peek+0x14>\n  843      s++;\n  ...\n  848    \n  849    s = *ps;\n  850:   while(s < es && strchr(whitespace, *s))\n  851       691:	8b 45 f4             	mov    -0xc(%ebp),%eax\n  852       694:	3b 45 0c             	cmp    0xc(%ebp),%eax\n  ...\n  857       6a2:	89 44 24 04          	mov    %eax,0x4(%esp)\n  858       6a6:	c7 04 24 24 1a 00 00 	movl   $0x1a24,(%esp)\n  859:      6ad:	e8 2f 07 00 00       	call   de1 <strchr>\n  860       6b2:	85 c0                	test   %eax,%eax\n  861       6b4:	75 d7                	jne    68d <peek+0x10>\n  ...\n  865       6b9:	8b 55 f4             	mov    -0xc(%ebp),%edx\n  866       6bc:	89 10                	mov    %edx,(%eax)\n  867:   return *s && strchr(toks, *s);\n  868       6be:	8b 45 f4             	mov    -0xc(%ebp),%eax\n  869       6c1:	0f b6 00             	movzbl (%eax),%eax\n  ...\n  876       6d5:	8b 45 10             	mov    0x10(%ebp),%eax\n  877       6d8:	89 04 24             	mov    %eax,(%esp)\n  878:      6db:	e8 01 07 00 00       	call   de1 <strchr>\n  879       6e0:	85 c0                	test   %eax,%eax\n  880       6e2:	74 07                	je     6eb <peek+0x6e>\n  ...\n  887  \n  888  000006f2 <parsecmd>:\n  889: struct cmd *parseexec(char**, char*);\n  890: struct cmd *nulterminate(struct cmd*);\n  891  \n  892: struct cmd*\n  893  parsecmd(char *s)\n  894  {\n  ...\n  898       6f6:	83 ec 24             	sub    $0x24,%esp\n  899    char *es;\n  900:   struct cmd *cmd;\n  901  \n  902:   es = s + strlen(s);\n  903       6f9:	8b 5d 08             	mov    0x8(%ebp),%ebx\n  904       6fc:	8b 45 08             	mov    0x8(%ebp),%eax\n  905       6ff:	89 04 24             	mov    %eax,(%esp)\n  906:      702:	e8 8f 06 00 00       	call   d96 <strlen>\n  907       707:	01 d8                	add    %ebx,%eax\n  908       709:	89 45 f4             	mov    %eax,-0xc(%ebp)\n  ...\n  951  0000077e <parseline>:\n  952  \n  953: struct cmd*\n  954  parseline(char **ps, char *es)\n  955  {\n  ...\n  957       77f:	89 e5                	mov    %esp,%ebp\n  958       781:	83 ec 28             	sub    $0x28,%esp\n  959:   struct cmd *cmd;\n  960  \n  961    cmd = parsepipe(ps, es);\n  ...\n  985  parseline(char **ps, char *es)\n  986  {\n  987:   struct cmd *cmd;\n  988  \n  989    cmd = parsepipe(ps, es);\n  ...\n 1041  00000852 <parsepipe>:\n 1042  \n 1043: struct cmd*\n 1044  parsepipe(char **ps, char *es)\n 1045  {\n ....\n 1047       853:	89 e5                	mov    %esp,%ebp\n 1048       855:	83 ec 28             	sub    $0x28,%esp\n 1049:   struct cmd *cmd;\n 1050  \n 1051    cmd = parseexec(ps, es);\n ....\n 1096  000008d6 <parseredirs>:\n 1097  \n 1098: struct cmd*\n 1099: parseredirs(struct cmd *cmd, char **ps, char *es)\n 1100  {\n 1101       8d6:	55                   	push   %ebp\n ....\n 1190        break;\n 1191       9d6:	90                   	nop\n 1192: parseredirs(struct cmd *cmd, char **ps, char *es)\n 1193  {\n 1194    int tok;\n ....\n 1218  000009fe <parseblock>:\n 1219  \n 1220: struct cmd*\n 1221  parseblock(char **ps, char *es)\n 1222  {\n ....\n 1224       9ff:	89 e5                	mov    %esp,%ebp\n 1225       a01:	83 ec 28             	sub    $0x28,%esp\n 1226:   struct cmd *cmd;\n 1227  \n 1228    if(!peek(ps, es, \"(\"))\n ....\n 1296  00000ad2 <parseexec>:\n 1297  \n 1298: struct cmd*\n 1299  parseexec(char **ps, char *es)\n 1300  {\n ....\n 1304    char *q, *eq;\n 1305    int tok, argc;\n 1306:   struct execcmd *cmd;\n 1307:   struct cmd *ret;\n 1308    \n 1309    if(peek(ps, es, \"(\"))\n ....\n 1328       b0d:	e8 93 f8 ff ff       	call   3a5 <execcmd>\n 1329       b12:	89 45 f0             	mov    %eax,-0x10(%ebp)\n 1330:   cmd = (struct execcmd*)ret;\n 1331       b15:	8b 45 f0             	mov    -0x10(%ebp),%eax\n 1332       b18:	89 45 ec             	mov    %eax,-0x14(%ebp)\n ....\n 1394       bce:	89 45 f0             	mov    %eax,-0x10(%ebp)\n 1395    ret = execcmd();\n 1396:   cmd = (struct execcmd*)ret;\n 1397  \n 1398    argc = 0;\n ....\n 1436  00000c1a <nulterminate>:\n 1437  \n 1438: // NUL-terminate all the counted strings.\n 1439: struct cmd*\n 1440: nulterminate(struct cmd *cmd)\n 1441  {\n 1442       c1a:	55                   	push   %ebp\n 1443       c1b:	89 e5                	mov    %esp,%ebp\n 1444       c1d:	83 ec 38             	sub    $0x38,%esp\n 1445:   struct execcmd *ecmd;\n 1446:   struct listcmd *lcmd;\n 1447:   struct pipecmd *pcmd;\n 1448:   struct redircmd *rcmd;\n 1449  \n 1450    if(cmd == 0)\n ....\n 1463       c45:	ff e0                	jmp    *%eax\n 1464    case EXEC:\n 1465:     ecmd = (struct execcmd*)cmd;\n 1466       c47:	8b 45 08             	mov    0x8(%ebp),%eax\n 1467       c4a:	89 45 f0             	mov    %eax,-0x10(%ebp)\n ....\n 1479    switch(cmd->type){\n 1480    case EXEC:\n 1481:     ecmd = (struct execcmd*)cmd;\n 1482      for(i=0; ecmd->argv[i]; i++)\n 1483       c66:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)\n ....\n 1492  \n 1493    case REDIR:\n 1494:     rcmd = (struct redircmd*)cmd;\n 1495       c7a:	8b 45 08             	mov    0x8(%ebp),%eax\n 1496       c7d:	89 45 ec             	mov    %eax,-0x14(%ebp)\n ....\n 1508  \n 1509    case PIPE:\n 1510:     pcmd = (struct pipecmd*)cmd;\n 1511       c99:	8b 45 08             	mov    0x8(%ebp),%eax\n 1512       c9c:	89 45 e8             	mov    %eax,-0x18(%ebp)\n ....\n 1525      \n 1526    case LIST:\n 1527:     lcmd = (struct listcmd*)cmd;\n 1528       cbd:	8b 45 08             	mov    0x8(%ebp),%eax\n 1529       cc0:	89 45 e4             	mov    %eax,-0x1c(%ebp)\n ....\n 1542  \n 1543    case BACK:\n 1544:     bcmd = (struct backcmd*)cmd;\n 1545       ce1:	8b 45 08             	mov    0x8(%ebp),%eax\n 1546       ce4:	89 45 e0             	mov    %eax,-0x20(%ebp)\n ....\n 1593       d20:	c3                   	ret    \n 1594  \n 1595: 00000d21 <strcpy>:\n 1596  #include \"user.h\"\n 1597  #include \"x86.h\"\n 1598  \n 1599  char*\n 1600: strcpy(char *s, char *t)\n 1601  {\n 1602       d21:	55                   	push   %ebp\n ....\n 1621       d48:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n 1622       d4c:	84 c0                	test   %al,%al\n 1623:      d4e:	75 de                	jne    d2e <strcpy+0xd>\n 1624      ;\n 1625    return os;\n ....\n 1629       d54:	c3                   	ret    \n 1630  \n 1631: 00000d55 <strcmp>:\n 1632  \n 1633  int\n 1634: strcmp(const char *p, const char *q)\n 1635  {\n 1636       d55:	55                   	push   %ebp\n 1637       d56:	89 e5                	mov    %esp,%ebp\n 1638    while(*p && *p == *q)\n 1639:      d58:	eb 08                	jmp    d62 <strcmp+0xd>\n 1640      p++, q++;\n 1641       d5a:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n ....\n 1644  \n 1645  int\n 1646: strcmp(const char *p, const char *q)\n 1647  {\n 1648    while(*p && *p == *q)\n ....\n 1650       d65:	0f b6 00             	movzbl (%eax),%eax\n 1651       d68:	84 c0                	test   %al,%al\n 1652:      d6a:	74 10                	je     d7c <strcmp+0x27>\n 1653       d6c:	8b 45 08             	mov    0x8(%ebp),%eax\n 1654       d6f:	0f b6 10             	movzbl (%eax),%edx\n ....\n 1656       d75:	0f b6 00             	movzbl (%eax),%eax\n 1657       d78:	38 c2                	cmp    %al,%dl\n 1658:      d7a:	74 de                	je     d5a <strcmp+0x5>\n 1659      p++, q++;\n 1660    return (uchar)*p - (uchar)*q;\n ....\n 1672       d95:	c3                   	ret    \n 1673  \n 1674: 00000d96 <strlen>:\n 1675  \n 1676  uint\n 1677: strlen(char *s)\n 1678  {\n 1679       d96:	55                   	push   %ebp\n ....\n 1684    for(n = 0; s[n]; n++)\n 1685       d9c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n 1686:      da3:	eb 04                	jmp    da9 <strlen+0x13>\n 1687       da5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n 1688       da9:	8b 55 fc             	mov    -0x4(%ebp),%edx\n ....\n 1691       db1:	0f b6 00             	movzbl (%eax),%eax\n 1692       db4:	84 c0                	test   %al,%al\n 1693:      db6:	75 ed                	jne    da5 <strlen+0xf>\n 1694      ;\n 1695    return n;\n ....\n 1721       de0:	c3                   	ret    \n 1722  \n 1723: 00000de1 <strchr>:\n 1724  \n 1725  char*\n 1726: strchr(const char *s, char c)\n 1727  {\n 1728       de1:	55                   	push   %ebp\n ....\n 1732       dea:	88 45 fc             	mov    %al,-0x4(%ebp)\n 1733    for(; *s; s++)\n 1734:      ded:	eb 14                	jmp    e03 <strchr+0x22>\n 1735      if(*s == c)\n 1736       def:	8b 45 08             	mov    0x8(%ebp),%eax\n 1737       df2:	0f b6 00             	movzbl (%eax),%eax\n 1738       df5:	3a 45 fc             	cmp    -0x4(%ebp),%al\n 1739:      df8:	75 05                	jne    dff <strchr+0x1e>\n 1740        return (char*)s;\n 1741       dfa:	8b 45 08             	mov    0x8(%ebp),%eax\n 1742:      dfd:	eb 13                	jmp    e12 <strchr+0x31>\n 1743  }\n 1744  \n 1745  char*\n 1746: strchr(const char *s, char c)\n 1747  {\n 1748    for(; *s; s++)\n ....\n 1751       e06:	0f b6 00             	movzbl (%eax),%eax\n 1752       e09:	84 c0                	test   %al,%al\n 1753:      e0b:	75 e2                	jne    def <strchr+0xe>\n 1754      if(*s == c)\n 1755        return (char*)s;\n ....\n 1833  \n 1834  int\n 1835: stat(char *n, struct stat *st)\n 1836  {\n 1837       e87:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/sh.c:\n   14  #define MAXARGS 10\n   15  \n   16: struct cmd {\n   17    int type;\n   18  };\n   19  \n   20: struct execcmd {\n   21    int type;\n   22    char *argv[MAXARGS];\n   ..\n   24  };\n   25  \n   26: struct redircmd {\n   27    int type;\n   28:   struct cmd *cmd;\n   29    char *file;\n   30    char *efile;\n   ..\n   33  };\n   34  \n   35: struct pipecmd {\n   36    int type;\n   37:   struct cmd *left;\n   38:   struct cmd *right;\n   39  };\n   40  \n   41: struct listcmd {\n   42    int type;\n   43:   struct cmd *left;\n   44:   struct cmd *right;\n   45  };\n   46  \n   47: struct backcmd {\n   48    int type;\n   49:   struct cmd *cmd;\n   50  };\n   51  \n   52  int fork1(void);  // Fork but panics on failure.\n   53  void panic(char*);\n   54: struct cmd *parsecmd(char*);\n   55  \n   56  // Execute cmd.  Never returns.\n   57  void\n   58: runcmd(struct cmd *cmd)\n   59  {\n   60    int p[2];\n   61:   struct backcmd *bcmd;\n   62:   struct execcmd *ecmd;\n   63:   struct listcmd *lcmd;\n   64:   struct pipecmd *pcmd;\n   65:   struct redircmd *rcmd;\n   66  \n   67    if(cmd == 0)\n   ..\n   73  \n   74    case EXEC:\n   75:     ecmd = (struct execcmd*)cmd;\n   76      if(ecmd->argv[0] == 0)\n   77        exit();\n   ..\n   81  \n   82    case REDIR:\n   83:     rcmd = (struct redircmd*)cmd;\n   84      close(rcmd->fd);\n   85      if(open(rcmd->file, rcmd->mode) < 0){\n   ..\n   91  \n   92    case LIST:\n   93:     lcmd = (struct listcmd*)cmd;\n   94      if(fork1() == 0)\n   95        runcmd(lcmd->left);\n   ..\n   99  \n  100    case PIPE:\n  101:     pcmd = (struct pipecmd*)cmd;\n  102      if(pipe(p) < 0)\n  103        panic(\"pipe\");\n  ...\n  123      \n  124    case BACK:\n  125:     bcmd = (struct backcmd*)cmd;\n  126      if(fork1() == 0)\n  127        runcmd(bcmd->cmd);\n  ...\n  161        // Clumsy but will have to do for now.\n  162        // Chdir has no effect on the parent if run in the child.\n  163:       buf[strlen(buf)-1] = 0;  // chop \\n\n  164        if(chdir(buf+3) < 0)\n  165          printf(2, \"cannot cd %s\\n\", buf+3);\n  ...\n  192  \n  193  //PAGEBREAK!\n  194: // Constructors\n  195  \n  196: struct cmd*\n  197  execcmd(void)\n  198  {\n  199:   struct execcmd *cmd;\n  200  \n  201    cmd = malloc(sizeof(*cmd));\n  202    memset(cmd, 0, sizeof(*cmd));\n  203    cmd->type = EXEC;\n  204:   return (struct cmd*)cmd;\n  205  }\n  206  \n  207: struct cmd*\n  208: redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)\n  209  {\n  210:   struct redircmd *cmd;\n  211  \n  212    cmd = malloc(sizeof(*cmd));\n  ...\n  218    cmd->mode = mode;\n  219    cmd->fd = fd;\n  220:   return (struct cmd*)cmd;\n  221  }\n  222  \n  223: struct cmd*\n  224: pipecmd(struct cmd *left, struct cmd *right)\n  225  {\n  226:   struct pipecmd *cmd;\n  227  \n  228    cmd = malloc(sizeof(*cmd));\n  ...\n  231    cmd->left = left;\n  232    cmd->right = right;\n  233:   return (struct cmd*)cmd;\n  234  }\n  235  \n  236: struct cmd*\n  237: listcmd(struct cmd *left, struct cmd *right)\n  238  {\n  239:   struct listcmd *cmd;\n  240  \n  241    cmd = malloc(sizeof(*cmd));\n  ...\n  244    cmd->left = left;\n  245    cmd->right = right;\n  246:   return (struct cmd*)cmd;\n  247  }\n  248  \n  249: struct cmd*\n  250: backcmd(struct cmd *subcmd)\n  251  {\n  252:   struct backcmd *cmd;\n  253  \n  254    cmd = malloc(sizeof(*cmd));\n  ...\n  256    cmd->type = BACK;\n  257    cmd->cmd = subcmd;\n  258:   return (struct cmd*)cmd;\n  259  }\n  260  //PAGEBREAK!\n  ...\n  271    \n  272    s = *ps;\n  273:   while(s < es && strchr(whitespace, *s))\n  274      s++;\n  275    if(q)\n  ...\n  296    default:\n  297      ret = 'a';\n  298:     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))\n  299        s++;\n  300      break;\n  ...\n  303      *eq = s;\n  304    \n  305:   while(s < es && strchr(whitespace, *s))\n  306      s++;\n  307    *ps = s;\n  ...\n  315    \n  316    s = *ps;\n  317:   while(s < es && strchr(whitespace, *s))\n  318      s++;\n  319    *ps = s;\n  320:   return *s && strchr(toks, *s);\n  321  }\n  322  \n  323: struct cmd *parseline(char**, char*);\n  324: struct cmd *parsepipe(char**, char*);\n  325: struct cmd *parseexec(char**, char*);\n  326: struct cmd *nulterminate(struct cmd*);\n  327  \n  328: struct cmd*\n  329  parsecmd(char *s)\n  330  {\n  331    char *es;\n  332:   struct cmd *cmd;\n  333  \n  334:   es = s + strlen(s);\n  335    cmd = parseline(&s, es);\n  336    peek(&s, es, \"\");\n  ...\n  343  }\n  344  \n  345: struct cmd*\n  346  parseline(char **ps, char *es)\n  347  {\n  348:   struct cmd *cmd;\n  349  \n  350    cmd = parsepipe(ps, es);\n  ...\n  360  }\n  361  \n  362: struct cmd*\n  363  parsepipe(char **ps, char *es)\n  364  {\n  365:   struct cmd *cmd;\n  366  \n  367    cmd = parseexec(ps, es);\n  ...\n  373  }\n  374  \n  375: struct cmd*\n  376: parseredirs(struct cmd *cmd, char **ps, char *es)\n  377  {\n  378    int tok;\n  ...\n  398  }\n  399  \n  400: struct cmd*\n  401  parseblock(char **ps, char *es)\n  402  {\n  403:   struct cmd *cmd;\n  404  \n  405    if(!peek(ps, es, \"(\"))\n  ...\n  414  }\n  415  \n  416: struct cmd*\n  417  parseexec(char **ps, char *es)\n  418  {\n  419    char *q, *eq;\n  420    int tok, argc;\n  421:   struct execcmd *cmd;\n  422:   struct cmd *ret;\n  423    \n  424    if(peek(ps, es, \"(\"))\n  ...\n  426  \n  427    ret = execcmd();\n  428:   cmd = (struct execcmd*)ret;\n  429  \n  430    argc = 0;\n  ...\n  447  }\n  448  \n  449: // NUL-terminate all the counted strings.\n  450: struct cmd*\n  451: nulterminate(struct cmd *cmd)\n  452  {\n  453    int i;\n  454:   struct backcmd *bcmd;\n  455:   struct execcmd *ecmd;\n  456:   struct listcmd *lcmd;\n  457:   struct pipecmd *pcmd;\n  458:   struct redircmd *rcmd;\n  459  \n  460    if(cmd == 0)\n  ...\n  463    switch(cmd->type){\n  464    case EXEC:\n  465:     ecmd = (struct execcmd*)cmd;\n  466      for(i=0; ecmd->argv[i]; i++)\n  467        *ecmd->eargv[i] = 0;\n  ...\n  469  \n  470    case REDIR:\n  471:     rcmd = (struct redircmd*)cmd;\n  472      nulterminate(rcmd->cmd);\n  473      *rcmd->efile = 0;\n  ...\n  475  \n  476    case PIPE:\n  477:     pcmd = (struct pipecmd*)cmd;\n  478      nulterminate(pcmd->left);\n  479      nulterminate(pcmd->right);\n  ...\n  481      \n  482    case LIST:\n  483:     lcmd = (struct listcmd*)cmd;\n  484      nulterminate(lcmd->left);\n  485      nulterminate(lcmd->right);\n  ...\n  487  \n  488    case BACK:\n  489:     bcmd = (struct backcmd*)cmd;\n  490      nulterminate(bcmd->cmd);\n  491      break;\n\n/home/oron/os142/assignment1/sh.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 sh.c\n   ..\n   24  00001379 morecore\n   25  00000000 \n   26: 00000d21 strcpy\n   27  000010e1 printf\n   28  00000f20 memmove\n   ..\n   64  00000dbd memset\n   65  00000267 main\n   66: 00000d55 strcmp\n   67  00000fdc dup\n   68  0000044e pipecmd\n   ..\n   74  00000f64 exit\n   75  00000ed5 atoi\n   76: 00000d96 strlen\n   77  00000fa4 open\n   78: 00000de1 strchr\n   79  00000fcc mkdir\n   80  00000f8c close\n\n/home/oron/os142/assignment1/spinlock.c:\n   11  \n   12  void\n   13: initlock(struct spinlock *lk, char *name)\n   14  {\n   15    lk->name = name;\n   ..\n   23  // other CPUs to waste time spinning to acquire it.\n   24  void\n   25: acquire(struct spinlock *lk)\n   26  {\n   27    pushcli(); // disable interrupts to avoid deadlock.\n   ..\n   42  // Release the lock.\n   43  void\n   44: release(struct spinlock *lk)\n   45  {\n   46    if(!holding(lk))\n   ..\n   84  // Check whether this cpu is holding the lock.\n   85  int\n   86: holding(struct spinlock *lock)\n   87  {\n   88    return lock->locked && lock->cpu == cpu;\n\n/home/oron/os142/assignment1/spinlock.h:\n    1  // Mutual exclusion lock.\n    2: struct spinlock {\n    3    uint locked;       // Is the lock held?\n    4    \n    5    // For debugging:\n    6    char *name;        // Name of lock.\n    7:   struct cpu *cpu;   // The cpu holding the lock.\n    8    uint pcs[10];      // The call stack (an array of program counters)\n    9                       // that locked the lock.\n\n/home/oron/os142/assignment1/stat.h:\n    3  #define T_DEV  3   // Special device\n    4  \n    5: struct stat {\n    6    short type;  // Type of file\n    7    int dev;     // Device number\n\n/home/oron/os142/assignment1/stressfs.asm:\n    1  \n    2: _stressfs:     file format elf32-i386\n    3  \n    4  \n    .\n   17     6:	81 ec 30 02 00 00    	sub    $0x230,%esp\n   18    int fd, i;\n   19:   char path[] = \"stressfs0\";\n   20     c:	c7 84 24 1e 02 00 00 	movl   $0x65727473,0x21e(%esp)\n   21    13:	73 74 72 65 \n   ..\n   26    char data[512];\n   27  \n   28:   printf(1, \"stressfs starting\\n\");\n   29    2c:	c7 44 24 04 69 09 00 	movl   $0x969,0x4(%esp)\n   30    33:	00 \n   ..\n   50    char data[512];\n   51  \n   52:   printf(1, \"stressfs starting\\n\");\n   53    memset(data, 'a', sizeof(data));\n   54  \n   ..\n  198   1d8:	c3                   	ret    \n  199  \n  200: 000001d9 <strcpy>:\n  201  #include \"user.h\"\n  202  #include \"x86.h\"\n  203  \n  204  char*\n  205: strcpy(char *s, char *t)\n  206  {\n  207   1d9:	55                   	push   %ebp\n  ...\n  226   200:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  227   204:	84 c0                	test   %al,%al\n  228:  206:	75 de                	jne    1e6 <strcpy+0xd>\n  229      ;\n  230    return os;\n  ...\n  234   20c:	c3                   	ret    \n  235  \n  236: 0000020d <strcmp>:\n  237  \n  238  int\n  239: strcmp(const char *p, const char *q)\n  240  {\n  241   20d:	55                   	push   %ebp\n  242   20e:	89 e5                	mov    %esp,%ebp\n  243    while(*p && *p == *q)\n  244:  210:	eb 08                	jmp    21a <strcmp+0xd>\n  245      p++, q++;\n  246   212:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  249  \n  250  int\n  251: strcmp(const char *p, const char *q)\n  252  {\n  253    while(*p && *p == *q)\n  ...\n  255   21d:	0f b6 00             	movzbl (%eax),%eax\n  256   220:	84 c0                	test   %al,%al\n  257:  222:	74 10                	je     234 <strcmp+0x27>\n  258   224:	8b 45 08             	mov    0x8(%ebp),%eax\n  259   227:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  261   22d:	0f b6 00             	movzbl (%eax),%eax\n  262   230:	38 c2                	cmp    %al,%dl\n  263:  232:	74 de                	je     212 <strcmp+0x5>\n  264      p++, q++;\n  265    return (uchar)*p - (uchar)*q;\n  ...\n  277   24d:	c3                   	ret    \n  278  \n  279: 0000024e <strlen>:\n  280  \n  281  uint\n  282: strlen(char *s)\n  283  {\n  284   24e:	55                   	push   %ebp\n  ...\n  289    for(n = 0; s[n]; n++)\n  290   254:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  291:  25b:	eb 04                	jmp    261 <strlen+0x13>\n  292   25d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  293   261:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  296   269:	0f b6 00             	movzbl (%eax),%eax\n  297   26c:	84 c0                	test   %al,%al\n  298:  26e:	75 ed                	jne    25d <strlen+0xf>\n  299      ;\n  300    return n;\n  ...\n  326   298:	c3                   	ret    \n  327  \n  328: 00000299 <strchr>:\n  329  \n  330  char*\n  331: strchr(const char *s, char c)\n  332  {\n  333   299:	55                   	push   %ebp\n  ...\n  337   2a2:	88 45 fc             	mov    %al,-0x4(%ebp)\n  338    for(; *s; s++)\n  339:  2a5:	eb 14                	jmp    2bb <strchr+0x22>\n  340      if(*s == c)\n  341   2a7:	8b 45 08             	mov    0x8(%ebp),%eax\n  342   2aa:	0f b6 00             	movzbl (%eax),%eax\n  343   2ad:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  344:  2b0:	75 05                	jne    2b7 <strchr+0x1e>\n  345        return (char*)s;\n  346   2b2:	8b 45 08             	mov    0x8(%ebp),%eax\n  347:  2b5:	eb 13                	jmp    2ca <strchr+0x31>\n  348  }\n  349  \n  350  char*\n  351: strchr(const char *s, char c)\n  352  {\n  353    for(; *s; s++)\n  ...\n  356   2be:	0f b6 00             	movzbl (%eax),%eax\n  357   2c1:	84 c0                	test   %al,%al\n  358:  2c3:	75 e2                	jne    2a7 <strchr+0xe>\n  359      if(*s == c)\n  360        return (char*)s;\n  ...\n  438  \n  439  int\n  440: stat(char *n, struct stat *st)\n  441  {\n  442   33f:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/stressfs.c:\n    1: // Demonstrate that moving the \"acquire\" in iderw after the loop that\n    2  // appends to the idequeue results in a race.\n    3  \n    4  // For this to work, you should also add a spin within iderw's\n    5: // idequeue traversal loop.  Adding the following demonstrated a panic\n    6: // after about 5 runs of stressfs in QEMU on a 2.1GHz CPU:\n    7  //    for (i = 0; i < 40000; i++)\n    8  //      asm volatile(\"\");\n    .\n   18  {\n   19    int fd, i;\n   20:   char path[] = \"stressfs0\";\n   21    char data[512];\n   22  \n   23:   printf(1, \"stressfs starting\\n\");\n   24    memset(data, 'a', sizeof(data));\n   25  \n\n/home/oron/os142/assignment1/stressfs.d:\n    1: stressfs.o: stressfs.c types.h stat.h user.h fs.h fcntl.h\n    2  \n\n/home/oron/os142/assignment1/stressfs.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13: 00000000 stressfs.c\n   14  00000000 ulib.c\n   15  000001b4 stosb\n   ..\n   23  00000831 morecore\n   24  00000000 \n   25: 000001d9 strcpy\n   26  00000599 printf\n   27  000003d8 memmove\n   ..\n   46  00000275 memset\n   47  00000000 main\n   48: 0000020d strcmp\n   49  00000494 dup\n   50  0000033f stat\n   ..\n   54  0000041c exit\n   55  0000038d atoi\n   56: 0000024e strlen\n   57  0000045c open\n   58: 00000299 strchr\n   59  00000484 mkdir\n   60  00000444 close\n\n/home/oron/os142/assignment1/string.c:\n   57  \n   58  int\n   59: strncmp(const char *p, const char *q, uint n)\n   60  {\n   61    while(n > 0 && *p && *p == *q)\n   ..\n   67  \n   68  char*\n   69: strncpy(char *s, const char *t, int n)\n   70  {\n   71    char *os;\n   ..\n   79  }\n   80  \n   81: // Like strncpy but guaranteed to NUL-terminate.\n   82  char*\n   83: safestrcpy(char *s, const char *t, int n)\n   84  {\n   85    char *os;\n   ..\n   95  \n   96  int\n   97: strlen(const char *s)\n   98  {\n   99    int n;\n\n/home/oron/os142/assignment1/swtch.S:\n    1  # Context switch\n    2  #\n    3: #   void swtch(struct context **old, struct context *new);\n    4  # \n    5  # Save current register context in old\n\n/home/oron/os142/assignment1/symlink.patch:\n    5   // If parent != 0, return the inode for the parent and copy the final\n    6   // path element into name, which must have room for DIRSIZ bytes.\n    7:  static struct inode*\n    8  -_namei(char *path, int parent, char *name)\n    9: +_namei(struct inode *root, char *path, int parent, char *name, int depth)\n   10   {\n   11:    struct inode *ip, *next;\n   12  +  char buf[100], tname[DIRSIZ];\n   13  +\n   ..\n   56   }\n   57   \n   58:  struct inode*\n   59   nameiparent(char *path, char *name)\n   60   {\n   ..\n   66  --- a/fs.h	Thu Aug 30 14:32:06 2007 -0400\n   67  +++ b/fs.h	Thu Aug 30 13:05:43 2007 -0400\n   68: @@ -33,6 +33,7 @@ struct dinode {\n   69   #define T_DIR  1   // Directory\n   70   #define T_FILE 2   // File\n   ..\n   73   \n   74   // Inodes per block.\n   75:  #define IPB           (BSIZE / sizeof(struct dinode))\n   76  diff -r f8a4e40ab1d6 syscall.c\n   77  --- a/syscall.c	Thu Aug 30 14:32:06 2007 -0400\n   ..\n  111  +{\n  112  +  char *old, *new;\n  113: +  struct inode *ip;\n  114  +  \n  115: +  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)\n  116  +    return -1;\n  117  +  if((ip = create(new, 0, T_SYMLINK, 0, 0)) == 0)\n  118  +    return -1;\n  119: +  writei(ip, old, 0, strlen(old));\n  120  +  iunlockput(ip);\n  121  +  return 0;\n  ...\n  141   \n  142   // ulib.c\n  143:  int stat(char*, struct stat*);\n  144  diff -r f8a4e40ab1d6 usys.S\n  145  --- a/usys.S	Thu Aug 30 14:32:06 2007 -0400\n\n/home/oron/os142/assignment1/syscall.c:\n   16  // Fetch the int at addr from process p.\n   17  int\n   18: fetchint(struct proc *p, uint addr, int *ip)\n   19  {\n   20    if(addr >= p->sz || addr+4 > p->sz)\n   ..\n   24  }\n   25  \n   26: // Fetch the nul-terminated string at addr from process p.\n   27: // Doesn't actually copy the string - just sets *pp to point at it.\n   28: // Returns length of string, not including nul.\n   29  int\n   30: fetchstr(struct proc *p, uint addr, char **pp)\n   31  {\n   32    char *s, *ep;\n   ..\n   65  }\n   66  \n   67: // Fetch the nth word-sized system call argument as a string pointer.\n   68: // Check that the pointer is valid and the string is nul-terminated.\n   69: // (There is no shared writable memory, so the string can't change\n   70  // between this check and being used by the kernel.)\n   71  int\n   72: argstr(int n, char **pp)\n   73  {\n   74    int addr;\n   75    if(argint(n, &addr) < 0)\n   76      return -1;\n   77:   return fetchstr(proc, addr, pp);\n   78  }\n   79  \n\n/home/oron/os142/assignment1/sysfile.c:\n   16  \n   17  // Fetch the nth word-sized system call argument as a file descriptor\n   18: // and return both the descriptor and the corresponding struct file.\n   19  static int\n   20: argfd(int n, int *pfd, struct file **pf)\n   21  {\n   22    int fd;\n   23:   struct file *f;\n   24  \n   25    if(argint(n, &fd) < 0)\n   ..\n   37  // Takes over file reference from caller on success.\n   38  static int\n   39: fdalloc(struct file *f)\n   40  {\n   41    int fd;\n   ..\n   53  sys_dup(void)\n   54  {\n   55:   struct file *f;\n   56    int fd;\n   57    \n   ..\n   67  sys_read(void)\n   68  {\n   69:   struct file *f;\n   70    int n;\n   71    char *p;\n   ..\n   79  sys_write(void)\n   80  {\n   81:   struct file *f;\n   82    int n;\n   83    char *p;\n   ..\n   92  {\n   93    int fd;\n   94:   struct file *f;\n   95    \n   96    if(argfd(0, &fd, &f) < 0)\n   ..\n  104  sys_fstat(void)\n  105  {\n  106:   struct file *f;\n  107:   struct stat *st;\n  108    \n  109    if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)\n  ...\n  117  {\n  118    char name[DIRSIZ], *new, *old;\n  119:   struct inode *dp, *ip;\n  120  \n  121:   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)\n  122      return -1;\n  123    if((ip = namei(old)) == 0)\n  ...\n  162  // Is the directory dp empty except for \".\" and \"..\" ?\n  163  static int\n  164: isdirempty(struct inode *dp)\n  165  {\n  166    int off;\n  167:   struct dirent de;\n  168  \n  169    for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){\n  ...\n  180  sys_unlink(void)\n  181  {\n  182:   struct inode *ip, *dp;\n  183:   struct dirent de;\n  184    char name[DIRSIZ], *path;\n  185    uint off;\n  186  \n  187:   if(argstr(0, &path) < 0)\n  188      return -1;\n  189    if((dp = nameiparent(path, name)) == 0)\n  ...\n  232  }\n  233  \n  234: static struct inode*\n  235  create(char *path, short type, short major, short minor)\n  236  {\n  237    uint off;\n  238:   struct inode *ip, *dp;\n  239    char name[DIRSIZ];\n  240  \n  ...\n  282    char *path;\n  283    int fd, omode;\n  284:   struct file *f;\n  285:   struct inode *ip;\n  286  \n  287:   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)\n  288      return -1;\n  289    if(omode & O_CREATE){\n  ...\n  323  {\n  324    char *path;\n  325:   struct inode *ip;\n  326  \n  327    begin_trans();\n  328:   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){\n  329      commit_trans();\n  330      return -1;\n  ...\n  338  sys_mknod(void)\n  339  {\n  340:   struct inode *ip;\n  341    char *path;\n  342    int len;\n  ...\n  344    \n  345    begin_trans();\n  346:   if((len=argstr(0, &path)) < 0 ||\n  347       argint(1, &major) < 0 ||\n  348       argint(2, &minor) < 0 ||\n  ...\n  360  {\n  361    char *path;\n  362:   struct inode *ip;\n  363  \n  364:   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0)\n  365      return -1;\n  366    ilock(ip);\n  ...\n  382    uint uargv, uarg;\n  383  \n  384:   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){\n  385      return -1;\n  386    }\n  ...\n  395        break;\n  396      }\n  397:     if(fetchstr(proc, uarg, &argv[i]) < 0)\n  398        return -1;\n  399    }\n  ...\n  405  {\n  406    int *fd;\n  407:   struct file *rf, *wf;\n  408    int fd0, fd1;\n  409  \n\n/home/oron/os142/assignment1/toc.ftr:\n    2  \n    3  The source listing is preceded by a cross-reference that lists every defined \n    4: constant, struct, global variable, and function in xv6.  Each entry gives,\n    5  on the same line as the name, the line number (or, in a few cases, numbers)\n    6  where the name is defined.  Successive lines in an entry list the line\n\n/home/oron/os142/assignment1/trap.c:\n   10  \n   11  // Interrupt descriptor table (shared by all CPUs).\n   12: struct gatedesc idt[256];\n   13  extern uint vectors[];  // in vectors.S: array of 256 entry pointers\n   14: struct spinlock tickslock;\n   15  uint ticks;\n   16  \n   ..\n   35  //PAGEBREAK: 41\n   36  void\n   37: trap(struct trapframe *tf)\n   38  {\n   39    if(tf->trapno == T_SYSCALL){\n\n/home/oron/os142/assignment1/ulib.c:\n    6  \n    7  char*\n    8: strcpy(char *s, char *t)\n    9  {\n   10    char *os;\n   ..\n   17  \n   18  int\n   19: strcmp(const char *p, const char *q)\n   20  {\n   21    while(*p && *p == *q)\n   ..\n   25  \n   26  uint\n   27: strlen(char *s)\n   28  {\n   29    int n;\n   ..\n   42  \n   43  char*\n   44: strchr(const char *s, char c)\n   45  {\n   46    for(; *s; s++)\n   ..\n   69  \n   70  int\n   71: stat(char *n, struct stat *st)\n   72  {\n   73    int fd;\n\n/home/oron/os142/assignment1/umalloc.c:\n   10  \n   11  union header {\n   12:   struct {\n   13      union header *ptr;\n   14      uint size;\n\n/home/oron/os142/assignment1/user.h:\n    1: struct stat;\n    2  \n    3  // system calls\n    .\n   14  int mknod(char*, short, short);\n   15  int unlink(char*);\n   16: int fstat(int fd, struct stat*);\n   17  int link(char*, char*);\n   18  int mkdir(char*);\n   ..\n   25  \n   26  // ulib.c\n   27: int stat(char*, struct stat*);\n   28: char* strcpy(char*, char*);\n   29  void *memmove(void*, void*, int);\n   30: char* strchr(const char*, char c);\n   31: int strcmp(const char*, const char*);\n   32  void printf(int, char*, ...);\n   33  char* gets(char*, int max);\n   34: uint strlen(char*);\n   35  void* memset(void*, int, uint);\n   36  void* malloc(uint);\n\n/home/oron/os142/assignment1/usertests.asm:\n 2385      168a:	89 e5                	mov    %esp,%ebp\n 2386      168c:	83 ec 68             	sub    $0x68,%esp\n 2387:   struct {\n 2388      ushort inum;\n 2389      char name[14];\n ....\n 5261      33ef:	e8 50 08 00 00       	call   3c44 <wait>\n 5262  \n 5263:     // try to crash the kernel by passing in a bad string pointer\n 5264      if(link(\"nosuchfile\", (char*)p) != -1){\n 5265      33f4:	8b 45 f4             	mov    -0xc(%ebp),%eax\n ....\n 5365  // does exec return an error if the arguments\n 5366  // are larger than a page? or does it write\n 5367: // below the stack and wreck the instructions/data?\n 5368  void\n 5369  bigargtest(void)\n ....\n 5956      39f8:	c3                   	ret    \n 5957  \n 5958: 000039f9 <strcpy>:\n 5959  #include \"user.h\"\n 5960  #include \"x86.h\"\n 5961  \n 5962  char*\n 5963: strcpy(char *s, char *t)\n 5964  {\n 5965      39f9:	55                   	push   %ebp\n ....\n 5984      3a20:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n 5985      3a24:	84 c0                	test   %al,%al\n 5986:     3a26:	75 de                	jne    3a06 <strcpy+0xd>\n 5987      ;\n 5988    return os;\n ....\n 5992      3a2c:	c3                   	ret    \n 5993  \n 5994: 00003a2d <strcmp>:\n 5995  \n 5996  int\n 5997: strcmp(const char *p, const char *q)\n 5998  {\n 5999      3a2d:	55                   	push   %ebp\n 6000      3a2e:	89 e5                	mov    %esp,%ebp\n 6001    while(*p && *p == *q)\n 6002:     3a30:	eb 08                	jmp    3a3a <strcmp+0xd>\n 6003      p++, q++;\n 6004      3a32:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n ....\n 6007  \n 6008  int\n 6009: strcmp(const char *p, const char *q)\n 6010  {\n 6011    while(*p && *p == *q)\n ....\n 6013      3a3d:	0f b6 00             	movzbl (%eax),%eax\n 6014      3a40:	84 c0                	test   %al,%al\n 6015:     3a42:	74 10                	je     3a54 <strcmp+0x27>\n 6016      3a44:	8b 45 08             	mov    0x8(%ebp),%eax\n 6017      3a47:	0f b6 10             	movzbl (%eax),%edx\n ....\n 6019      3a4d:	0f b6 00             	movzbl (%eax),%eax\n 6020      3a50:	38 c2                	cmp    %al,%dl\n 6021:     3a52:	74 de                	je     3a32 <strcmp+0x5>\n 6022      p++, q++;\n 6023    return (uchar)*p - (uchar)*q;\n ....\n 6035      3a6d:	c3                   	ret    \n 6036  \n 6037: 00003a6e <strlen>:\n 6038  \n 6039  uint\n 6040: strlen(char *s)\n 6041  {\n 6042      3a6e:	55                   	push   %ebp\n ....\n 6047    for(n = 0; s[n]; n++)\n 6048      3a74:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n 6049:     3a7b:	eb 04                	jmp    3a81 <strlen+0x13>\n 6050      3a7d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n 6051      3a81:	8b 55 fc             	mov    -0x4(%ebp),%edx\n ....\n 6054      3a89:	0f b6 00             	movzbl (%eax),%eax\n 6055      3a8c:	84 c0                	test   %al,%al\n 6056:     3a8e:	75 ed                	jne    3a7d <strlen+0xf>\n 6057      ;\n 6058    return n;\n ....\n 6084      3ab8:	c3                   	ret    \n 6085  \n 6086: 00003ab9 <strchr>:\n 6087  \n 6088  char*\n 6089: strchr(const char *s, char c)\n 6090  {\n 6091      3ab9:	55                   	push   %ebp\n ....\n 6095      3ac2:	88 45 fc             	mov    %al,-0x4(%ebp)\n 6096    for(; *s; s++)\n 6097:     3ac5:	eb 14                	jmp    3adb <strchr+0x22>\n 6098      if(*s == c)\n 6099      3ac7:	8b 45 08             	mov    0x8(%ebp),%eax\n 6100      3aca:	0f b6 00             	movzbl (%eax),%eax\n 6101      3acd:	3a 45 fc             	cmp    -0x4(%ebp),%al\n 6102:     3ad0:	75 05                	jne    3ad7 <strchr+0x1e>\n 6103        return (char*)s;\n 6104      3ad2:	8b 45 08             	mov    0x8(%ebp),%eax\n 6105:     3ad5:	eb 13                	jmp    3aea <strchr+0x31>\n 6106  }\n 6107  \n 6108  char*\n 6109: strchr(const char *s, char c)\n 6110  {\n 6111    for(; *s; s++)\n ....\n 6114      3ade:	0f b6 00             	movzbl (%eax),%eax\n 6115      3ae1:	84 c0                	test   %al,%al\n 6116:     3ae3:	75 e2                	jne    3ac7 <strchr+0xe>\n 6117      if(*s == c)\n 6118        return (char*)s;\n ....\n 6196  \n 6197  int\n 6198: stat(char *n, struct stat *st)\n 6199  {\n 6200      3b5f:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/usertests.c:\n  670    int i, pid, n, fd;\n  671    char fa[40];\n  672:   struct {\n  673      ushort inum;\n  674      char name[14];\n  ...\n 1482      wait();\n 1483  \n 1484:     // try to crash the kernel by passing in a bad string pointer\n 1485      if(link(\"nosuchfile\", (char*)p) != -1){\n 1486        printf(stdout, \"link should not succeed\\n\");\n ....\n 1511  // does exec return an error if the arguments\n 1512  // are larger than a page? or does it write\n 1513: // below the stack and wreck the instructions/data?\n 1514  void\n 1515  bigargtest(void)\n\n/home/oron/os142/assignment1/usertests.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 .debug_ranges\n   ..\n   25  00004051 morecore\n   26  00000000 \n   27: 000039f9 strcpy\n   28  000009f1 exitwait\n   29  00003db9 printf\n   ..\n   72  000038cd main\n   73  00000fba createdelete\n   74: 00003a2d strcmp\n   75  000000ab writetest\n   76  00003cb4 dup\n   ..\n   92  00001a42 linkunlink\n   93  0000a6c0 name\n   94: 00003a6e strlen\n   95  00003c7c open\n   96: 00003ab9 strchr\n   97  00001689 concreate\n   98  00002758 fourteen\n\n/home/oron/os142/assignment1/uthread.h:\n   22  // Represents a ULT. \n   23  // Feel free to extend this definition as needed.\n   24: typedef struct\n   25  {\n   26  	int tid;				// A unique thread ID within the process\n\n/home/oron/os142/assignment1/vm.c:\n   10  extern char data[];  // defined by kernel.ld\n   11  pde_t *kpgdir;  // for use in scheduler()\n   12: struct segdesc gdt[NSEGS];\n   13  \n   14  // Set up CPU's kernel segment descriptors.\n   ..\n   17  seginit(void)\n   18  {\n   19:   struct cpu *c;\n   20  \n   21    // Map \"logical\" addresses to virtual addresses using identity map.\n   ..\n   58      memset(pgtab, 0, PGSIZE);\n   59      // The permissions here are overly generous, but they can\n   60:     // be further restricted by the permissions in the page table \n   61      // entries, if necessary.\n   62      *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;\n   ..\n  102  //   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)\n  103  //   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)\n  104: //                for the kernel's instructions and r/o data\n  105  //   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP, \n  106  //                                  rw data + free physical memory\n  ...\n  113  // This table defines the kernel's mappings, which are present in\n  114  // every process's page table.\n  115: static struct kmap {\n  116    void *virt;\n  117    uint phys_start;\n  ...\n  130  {\n  131    pde_t *pgdir;\n  132:   struct kmap *k;\n  133  \n  134    if((pgdir = (pde_t*)kalloc()) == 0)\n  ...\n  163  // Switch TSS and h/w page table to correspond to process p.\n  164  void\n  165: switchuvm(struct proc *p)\n  166  {\n  167    pushcli();\n  ...\n  195  // and the pages from addr to addr+sz must already be mapped.\n  196  int\n  197: loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)\n  198  {\n  199    uint i, pa, n;\n\n/home/oron/os142/assignment1/wc.asm:\n   41          l++;\n   42    3e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)\n   43:       if(strchr(\" \\r\\t\\n\\v\", buf[i]))\n   44    42:	8b 45 f4             	mov    -0xc(%ebp),%eax\n   45    45:	05 80 0c 00 00       	add    $0xc80,%eax\n   ..\n   48    50:	89 44 24 04          	mov    %eax,0x4(%esp)\n   49    54:	c7 04 24 91 09 00 00 	movl   $0x991,(%esp)\n   50:   5b:	e8 61 02 00 00       	call   2c1 <strchr>\n   51    60:	85 c0                	test   %eax,%eax\n   52    62:	74 09                	je     6d <wc+0x6d>\n   ..\n  241   200:	c3                   	ret    \n  242  \n  243: 00000201 <strcpy>:\n  244  #include \"user.h\"\n  245  #include \"x86.h\"\n  246  \n  247  char*\n  248: strcpy(char *s, char *t)\n  249  {\n  250   201:	55                   	push   %ebp\n  ...\n  269   228:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n  270   22c:	84 c0                	test   %al,%al\n  271:  22e:	75 de                	jne    20e <strcpy+0xd>\n  272      ;\n  273    return os;\n  ...\n  277   234:	c3                   	ret    \n  278  \n  279: 00000235 <strcmp>:\n  280  \n  281  int\n  282: strcmp(const char *p, const char *q)\n  283  {\n  284   235:	55                   	push   %ebp\n  285   236:	89 e5                	mov    %esp,%ebp\n  286    while(*p && *p == *q)\n  287:  238:	eb 08                	jmp    242 <strcmp+0xd>\n  288      p++, q++;\n  289   23a:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  292  \n  293  int\n  294: strcmp(const char *p, const char *q)\n  295  {\n  296    while(*p && *p == *q)\n  ...\n  298   245:	0f b6 00             	movzbl (%eax),%eax\n  299   248:	84 c0                	test   %al,%al\n  300:  24a:	74 10                	je     25c <strcmp+0x27>\n  301   24c:	8b 45 08             	mov    0x8(%ebp),%eax\n  302   24f:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  304   255:	0f b6 00             	movzbl (%eax),%eax\n  305   258:	38 c2                	cmp    %al,%dl\n  306:  25a:	74 de                	je     23a <strcmp+0x5>\n  307      p++, q++;\n  308    return (uchar)*p - (uchar)*q;\n  ...\n  320   275:	c3                   	ret    \n  321  \n  322: 00000276 <strlen>:\n  323  \n  324  uint\n  325: strlen(char *s)\n  326  {\n  327   276:	55                   	push   %ebp\n  ...\n  332    for(n = 0; s[n]; n++)\n  333   27c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  334:  283:	eb 04                	jmp    289 <strlen+0x13>\n  335   285:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  336   289:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  339   291:	0f b6 00             	movzbl (%eax),%eax\n  340   294:	84 c0                	test   %al,%al\n  341:  296:	75 ed                	jne    285 <strlen+0xf>\n  342      ;\n  343    return n;\n  ...\n  369   2c0:	c3                   	ret    \n  370  \n  371: 000002c1 <strchr>:\n  372  \n  373  char*\n  374: strchr(const char *s, char c)\n  375  {\n  376   2c1:	55                   	push   %ebp\n  ...\n  380   2ca:	88 45 fc             	mov    %al,-0x4(%ebp)\n  381    for(; *s; s++)\n  382:  2cd:	eb 14                	jmp    2e3 <strchr+0x22>\n  383      if(*s == c)\n  384   2cf:	8b 45 08             	mov    0x8(%ebp),%eax\n  385   2d2:	0f b6 00             	movzbl (%eax),%eax\n  386   2d5:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  387:  2d8:	75 05                	jne    2df <strchr+0x1e>\n  388        return (char*)s;\n  389   2da:	8b 45 08             	mov    0x8(%ebp),%eax\n  390:  2dd:	eb 13                	jmp    2f2 <strchr+0x31>\n  391  }\n  392  \n  393  char*\n  394: strchr(const char *s, char c)\n  395  {\n  396    for(; *s; s++)\n  ...\n  399   2e6:	0f b6 00             	movzbl (%eax),%eax\n  400   2e9:	84 c0                	test   %al,%al\n  401:  2eb:	75 e2                	jne    2cf <strchr+0xe>\n  402      if(*s == c)\n  403        return (char*)s;\n  ...\n  481  \n  482  int\n  483: stat(char *n, struct stat *st)\n  484  {\n  485   367:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/wc.c:\n   18        if(buf[i] == '\\n')\n   19          l++;\n   20:       if(strchr(\" \\r\\t\\n\\v\", buf[i]))\n   21          inword = 0;\n   22        else if(!inword){\n\n/home/oron/os142/assignment1/wc.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 wc.c\n   ..\n   23  00000859 morecore\n   24  00000000 \n   25: 00000201 strcpy\n   26  000005c1 printf\n   27  00000400 memmove\n   ..\n   47  0000029d memset\n   48  00000103 main\n   49: 00000235 strcmp\n   50  000004bc dup\n   51  00000c80 buf\n   ..\n   56  00000444 exit\n   57  000003b5 atoi\n   58: 00000276 strlen\n   59  00000484 open\n   60: 000002c1 strchr\n   61  000004ac mkdir\n   62  0000046c close\n\n/home/oron/os142/assignment1/x86.h:\n    1: // Routines to let C code use special x86 instructions.\n    2  \n    3  static inline uchar\n    .\n   58  }\n   59  \n   60: struct segdesc;\n   61  \n   62  static inline void\n   63: lgdt(struct segdesc *p, int size)\n   64  {\n   65    volatile ushort pd[3];\n   ..\n   72  }\n   73  \n   74: struct gatedesc;\n   75  \n   76  static inline void\n   77: lidt(struct gatedesc *p, int size)\n   78  {\n   79    volatile ushort pd[3];\n   ..\n  148  // Layout of the trap frame built on the stack by the\n  149  // hardware and by trapasm.S, and passed to trap().\n  150: struct trapframe {\n  151    // registers as pushed by pusha\n  152    uint edi;\n\n/home/oron/os142/assignment1/xv6-ass1.sublime-workspace:\n   78  		\"height\": 139.0\n   79  	},\n   80: 	\"distraction_free\":\n   81  	{\n   82  		\"menu_visible\": true,\n\n/home/oron/os142/assignment1/zombie.asm:\n   60    48:	c3                   	ret    \n   61  \n   62: 00000049 <strcpy>:\n   63  #include \"user.h\"\n   64  #include \"x86.h\"\n   65  \n   66  char*\n   67: strcpy(char *s, char *t)\n   68  {\n   69    49:	55                   	push   %ebp\n   ..\n   88    70:	83 45 0c 01          	addl   $0x1,0xc(%ebp)\n   89    74:	84 c0                	test   %al,%al\n   90:   76:	75 de                	jne    56 <strcpy+0xd>\n   91      ;\n   92    return os;\n   ..\n   96    7c:	c3                   	ret    \n   97  \n   98: 0000007d <strcmp>:\n   99  \n  100  int\n  101: strcmp(const char *p, const char *q)\n  102  {\n  103    7d:	55                   	push   %ebp\n  104    7e:	89 e5                	mov    %esp,%ebp\n  105    while(*p && *p == *q)\n  106:   80:	eb 08                	jmp    8a <strcmp+0xd>\n  107      p++, q++;\n  108    82:	83 45 08 01          	addl   $0x1,0x8(%ebp)\n  ...\n  111  \n  112  int\n  113: strcmp(const char *p, const char *q)\n  114  {\n  115    while(*p && *p == *q)\n  ...\n  117    8d:	0f b6 00             	movzbl (%eax),%eax\n  118    90:	84 c0                	test   %al,%al\n  119:   92:	74 10                	je     a4 <strcmp+0x27>\n  120    94:	8b 45 08             	mov    0x8(%ebp),%eax\n  121    97:	0f b6 10             	movzbl (%eax),%edx\n  ...\n  123    9d:	0f b6 00             	movzbl (%eax),%eax\n  124    a0:	38 c2                	cmp    %al,%dl\n  125:   a2:	74 de                	je     82 <strcmp+0x5>\n  126      p++, q++;\n  127    return (uchar)*p - (uchar)*q;\n  ...\n  139    bd:	c3                   	ret    \n  140  \n  141: 000000be <strlen>:\n  142  \n  143  uint\n  144: strlen(char *s)\n  145  {\n  146    be:	55                   	push   %ebp\n  ...\n  151    for(n = 0; s[n]; n++)\n  152    c4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)\n  153:   cb:	eb 04                	jmp    d1 <strlen+0x13>\n  154    cd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)\n  155    d1:	8b 55 fc             	mov    -0x4(%ebp),%edx\n  ...\n  158    d9:	0f b6 00             	movzbl (%eax),%eax\n  159    dc:	84 c0                	test   %al,%al\n  160:   de:	75 ed                	jne    cd <strlen+0xf>\n  161      ;\n  162    return n;\n  ...\n  188   108:	c3                   	ret    \n  189  \n  190: 00000109 <strchr>:\n  191  \n  192  char*\n  193: strchr(const char *s, char c)\n  194  {\n  195   109:	55                   	push   %ebp\n  ...\n  199   112:	88 45 fc             	mov    %al,-0x4(%ebp)\n  200    for(; *s; s++)\n  201:  115:	eb 14                	jmp    12b <strchr+0x22>\n  202      if(*s == c)\n  203   117:	8b 45 08             	mov    0x8(%ebp),%eax\n  204   11a:	0f b6 00             	movzbl (%eax),%eax\n  205   11d:	3a 45 fc             	cmp    -0x4(%ebp),%al\n  206:  120:	75 05                	jne    127 <strchr+0x1e>\n  207        return (char*)s;\n  208   122:	8b 45 08             	mov    0x8(%ebp),%eax\n  209:  125:	eb 13                	jmp    13a <strchr+0x31>\n  210  }\n  211  \n  212  char*\n  213: strchr(const char *s, char c)\n  214  {\n  215    for(; *s; s++)\n  ...\n  218   12e:	0f b6 00             	movzbl (%eax),%eax\n  219   131:	84 c0                	test   %al,%al\n  220:  133:	75 e2                	jne    117 <strchr+0xe>\n  221      if(*s == c)\n  222        return (char*)s;\n  ...\n  300  \n  301  int\n  302: stat(char *n, struct stat *st)\n  303  {\n  304   1af:	55                   	push   %ebp\n\n/home/oron/os142/assignment1/zombie.sym:\n    9  00000000 .debug_abbrev\n   10  00000000 .debug_line\n   11: 00000000 .debug_str\n   12  00000000 .debug_loc\n   13  00000000 zombie.c\n   ..\n   23  000006a1 morecore\n   24  00000000 \n   25: 00000049 strcpy\n   26  00000409 printf\n   27  00000248 memmove\n   ..\n   46  000000e5 memset\n   47  00000000 main\n   48: 0000007d strcmp\n   49  00000304 dup\n   50  000001af stat\n   ..\n   54  0000028c exit\n   55  000001fd atoi\n   56: 000000be strlen\n   57  000002cc open\n   58: 00000109 strchr\n   59  000002f4 mkdir\n   60  000002b4 close\n\n1105 matches across 94 files\n",
			"settings":
			{
				"buffer_size": 146873,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "init.c",
			"settings":
			{
				"buffer_size": 649,
				"line_ending": "Unix"
			}
		},
		{
			"file": "sh.c",
			"settings":
			{
				"buffer_size": 8307,
				"line_ending": "Unix"
			}
		},
		{
			"file": "fs.c",
			"settings":
			{
				"buffer_size": 14877,
				"line_ending": "Unix"
			}
		},
		{
			"file": "defs.h",
			"settings":
			{
				"buffer_size": 5280,
				"line_ending": "Unix"
			}
		},
		{
			"file": "echo.c",
			"settings":
			{
				"buffer_size": 198,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
			[
				"packa",
				"Package Control: Install Package"
			],
			[
				"pack",
				"Package Control: Discover Packages"
			],
			[
				"proj",
				"Project: Save As"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 139.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/home/oron/os142/assignment1/exec.c",
		"/home/oron/.config/sublime-text-2/Packages/Find Function Definition/go2function.sublime-settings",
		"/home/oron/os142/assignment1/sh.c",
		"/home/oron/os142/assignment1/xv6-ass1.sublime-workspace",
		"/home/oron/os142/assignment1/_sh"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
			"/home/oron/os142/assignment1",
			"/home/oron/os142/assignment1/",
			"/home/oron/os142/assignment1",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"strcpy",
			"str",
			"strcat",
			"panic",
			"namex",
			"iget",
			"namei",
			"fs.c",
			"namei",
			"failed",
			"exec failed",
			"namei",
			"exec",
			"runcmd",
			"parsecmd",
			"runcmd",
			"freevm",
			"return",
			"bad command",
			"10"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 6,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "console.c",
					"settings":
					{
						"buffer_size": 5158,
						"regions":
						{
						},
						"selection":
						[
							[
								697,
								697
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 373.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"settings":
					{
						"buffer_size": 146873,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										272,
										275
									],
									[
										377,
										380
									],
									[
										636,
										639
									],
									[
										816,
										819
									],
									[
										940,
										943
									],
									[
										1210,
										1213
									],
									[
										1373,
										1376
									],
									[
										1684,
										1687
									],
									[
										1904,
										1907
									],
									[
										2167,
										2170
									],
									[
										2448,
										2451
									],
									[
										2697,
										2700
									],
									[
										2883,
										2886
									],
									[
										3137,
										3140
									],
									[
										3341,
										3344
									],
									[
										3359,
										3362
									],
									[
										3390,
										3393
									],
									[
										3533,
										3536
									],
									[
										3618,
										3621
									],
									[
										3798,
										3801
									],
									[
										3863,
										3866
									],
									[
										4017,
										4020
									],
									[
										4083,
										4086
									],
									[
										4225,
										4228
									],
									[
										4363,
										4366
									],
									[
										4559,
										4562
									],
									[
										4775,
										4778
									],
									[
										5038,
										5041
									],
									[
										5255,
										5258
									],
									[
										5427,
										5430
									],
									[
										5677,
										5680
									],
									[
										5867,
										5870
									],
									[
										5896,
										5899
									],
									[
										5996,
										5999
									],
									[
										6168,
										6171
									],
									[
										6320,
										6323
									],
									[
										6403,
										6406
									],
									[
										6448,
										6451
									],
									[
										6475,
										6478
									],
									[
										6651,
										6654
									],
									[
										6737,
										6740
									],
									[
										6978,
										6981
									],
									[
										7097,
										7100
									],
									[
										7132,
										7135
									],
									[
										7355,
										7358
									],
									[
										7477,
										7480
									],
									[
										7711,
										7714
									],
									[
										7992,
										7995
									],
									[
										8138,
										8141
									],
									[
										8174,
										8177
									],
									[
										8388,
										8391
									],
									[
										8674,
										8677
									],
									[
										8792,
										8795
									],
									[
										8829,
										8832
									],
									[
										9049,
										9052
									],
									[
										9300,
										9303
									],
									[
										9447,
										9450
									],
									[
										9497,
										9500
									],
									[
										9717,
										9720
									],
									[
										9828,
										9831
									],
									[
										10021,
										10024
									],
									[
										10138,
										10141
									],
									[
										10258,
										10261
									],
									[
										10369,
										10372
									],
									[
										10413,
										10416
									],
									[
										10559,
										10562
									],
									[
										10577,
										10580
									],
									[
										10686,
										10689
									],
									[
										10704,
										10707
									],
									[
										10832,
										10835
									],
									[
										10944,
										10947
									],
									[
										11050,
										11053
									],
									[
										11069,
										11072
									],
									[
										11092,
										11095
									],
									[
										11112,
										11115
									],
									[
										11133,
										11136
									],
									[
										11153,
										11156
									],
									[
										11173,
										11176
									],
									[
										11197,
										11200
									],
									[
										11217,
										11220
									],
									[
										11303,
										11306
									],
									[
										11368,
										11371
									],
									[
										11412,
										11415
									],
									[
										11492,
										11495
									],
									[
										11558,
										11561
									],
									[
										11580,
										11583
									],
									[
										11604,
										11607
									],
									[
										11690,
										11693
									],
									[
										11751,
										11754
									],
									[
										11765,
										11768
									],
									[
										11813,
										11816
									],
									[
										11904,
										11907
									],
									[
										11959,
										11962
									],
									[
										11995,
										11998
									],
									[
										12021,
										12024
									],
									[
										12058,
										12061
									],
									[
										12102,
										12105
									],
									[
										12123,
										12126
									],
									[
										12204,
										12207
									],
									[
										12248,
										12251
									],
									[
										12295,
										12298
									],
									[
										12345,
										12348
									],
									[
										12392,
										12395
									],
									[
										12473,
										12476
									],
									[
										12510,
										12513
									],
									[
										12582,
										12585
									],
									[
										12646,
										12649
									],
									[
										12661,
										12664
									],
									[
										12706,
										12709
									],
									[
										12870,
										12873
									],
									[
										13004,
										13007
									],
									[
										13159,
										13162
									],
									[
										13174,
										13177
									],
									[
										13223,
										13226
									],
									[
										13275,
										13278
									],
									[
										13335,
										13338
									],
									[
										13417,
										13420
									],
									[
										13442,
										13445
									],
									[
										13671,
										13674
									],
									[
										13825,
										13828
									],
									[
										13843,
										13846
									],
									[
										13921,
										13924
									],
									[
										14022,
										14025
									],
									[
										14073,
										14076
									],
									[
										14130,
										14133
									],
									[
										14242,
										14245
									],
									[
										14448,
										14451
									],
									[
										14504,
										14507
									],
									[
										14548,
										14551
									],
									[
										14612,
										14615
									],
									[
										14791,
										14794
									],
									[
										14841,
										14844
									],
									[
										14896,
										14899
									],
									[
										14900,
										14903
									],
									[
										15062,
										15065
									],
									[
										15258,
										15261
									],
									[
										15365,
										15368
									],
									[
										15680,
										15683
									],
									[
										16064,
										16067
									],
									[
										16283,
										16286
									],
									[
										16721,
										16724
									],
									[
										17010,
										17013
									],
									[
										17325,
										17328
									],
									[
										17594,
										17597
									],
									[
										17918,
										17921
									],
									[
										18281,
										18284
									],
									[
										18622,
										18625
									],
									[
										18912,
										18915
									],
									[
										19200,
										19203
									],
									[
										19516,
										19519
									],
									[
										19825,
										19828
									],
									[
										20131,
										20134
									],
									[
										20217,
										20220
									],
									[
										20457,
										20460
									],
									[
										20576,
										20579
									],
									[
										20611,
										20614
									],
									[
										20833,
										20836
									],
									[
										20955,
										20958
									],
									[
										21188,
										21191
									],
									[
										21468,
										21471
									],
									[
										21614,
										21617
									],
									[
										21650,
										21653
									],
									[
										21864,
										21867
									],
									[
										22150,
										22153
									],
									[
										22268,
										22271
									],
									[
										22305,
										22308
									],
									[
										22525,
										22528
									],
									[
										22776,
										22779
									],
									[
										22923,
										22926
									],
									[
										22973,
										22976
									],
									[
										23193,
										23196
									],
									[
										23304,
										23307
									],
									[
										23498,
										23501
									],
									[
										23616,
										23619
									],
									[
										23736,
										23739
									],
									[
										23848,
										23851
									],
									[
										23892,
										23895
									],
									[
										24017,
										24020
									],
									[
										24177,
										24180
									],
									[
										24243,
										24246
									],
									[
										24505,
										24508
									],
									[
										24667,
										24670
									],
									[
										24828,
										24831
									],
									[
										24856,
										24859
									],
									[
										24883,
										24886
									],
									[
										25002,
										25005
									],
									[
										25165,
										25168
									],
									[
										25241,
										25244
									],
									[
										25394,
										25397
									],
									[
										25568,
										25571
									],
									[
										25601,
										25604
									],
									[
										25619,
										25622
									],
									[
										25650,
										25653
									],
									[
										25749,
										25752
									],
									[
										25767,
										25770
									],
									[
										25821,
										25824
									],
									[
										25940,
										25943
									],
									[
										25968,
										25971
									],
									[
										26130,
										26133
									],
									[
										26164,
										26167
									],
									[
										26290,
										26293
									],
									[
										26306,
										26309
									],
									[
										26427,
										26430
									],
									[
										26548,
										26551
									],
									[
										26653,
										26656
									],
									[
										26812,
										26815
									],
									[
										26840,
										26843
									],
									[
										26945,
										26948
									],
									[
										27138,
										27141
									],
									[
										27174,
										27177
									],
									[
										27224,
										27227
									],
									[
										27284,
										27287
									],
									[
										27510,
										27513
									],
									[
										27680,
										27683
									],
									[
										27876,
										27879
									],
									[
										27962,
										27965
									],
									[
										28203,
										28206
									],
									[
										28322,
										28325
									],
									[
										28357,
										28360
									],
									[
										28580,
										28583
									],
									[
										28702,
										28705
									],
									[
										28936,
										28939
									],
									[
										29217,
										29220
									],
									[
										29363,
										29366
									],
									[
										29399,
										29402
									],
									[
										29613,
										29616
									],
									[
										29899,
										29902
									],
									[
										30017,
										30020
									],
									[
										30054,
										30057
									],
									[
										30274,
										30277
									],
									[
										30525,
										30528
									],
									[
										30672,
										30675
									],
									[
										30722,
										30725
									],
									[
										30942,
										30945
									],
									[
										31053,
										31056
									],
									[
										31235,
										31238
									],
									[
										31383,
										31386
									],
									[
										31474,
										31477
									],
									[
										31515,
										31518
									],
									[
										31625,
										31628
									],
									[
										31729,
										31732
									],
									[
										31754,
										31757
									],
									[
										31855,
										31858
									],
									[
										31880,
										31883
									],
									[
										32023,
										32026
									],
									[
										32245,
										32248
									],
									[
										32263,
										32266
									],
									[
										32294,
										32297
									],
									[
										32384,
										32387
									],
									[
										32569,
										32572
									],
									[
										32656,
										32659
									],
									[
										32681,
										32684
									],
									[
										32710,
										32713
									],
									[
										32884,
										32887
									],
									[
										33095,
										33098
									],
									[
										33131,
										33134
									],
									[
										33156,
										33159
									],
									[
										33248,
										33251
									],
									[
										33479,
										33482
									],
									[
										33544,
										33547
									],
									[
										33720,
										33723
									],
									[
										33746,
										33749
									],
									[
										33886,
										33889
									],
									[
										33922,
										33925
									],
									[
										33947,
										33950
									],
									[
										34122,
										34125
									],
									[
										34297,
										34300
									],
									[
										34474,
										34477
									],
									[
										34611,
										34614
									],
									[
										34754,
										34757
									],
									[
										34823,
										34826
									],
									[
										34963,
										34966
									],
									[
										35018,
										35021
									],
									[
										35135,
										35138
									],
									[
										35153,
										35156
									],
									[
										35269,
										35272
									],
									[
										35356,
										35359
									],
									[
										35474,
										35477
									],
									[
										35561,
										35564
									],
									[
										35693,
										35696
									],
									[
										35848,
										35851
									],
									[
										35879,
										35882
									],
									[
										35964,
										35967
									],
									[
										36127,
										36130
									],
									[
										36204,
										36207
									],
									[
										36231,
										36234
									],
									[
										36335,
										36338
									],
									[
										36629,
										36632
									],
									[
										36715,
										36718
									],
									[
										36804,
										36807
									],
									[
										36882,
										36885
									],
									[
										37033,
										37036
									],
									[
										37255,
										37258
									],
									[
										37272,
										37275
									],
									[
										37486,
										37489
									],
									[
										37683,
										37686
									],
									[
										37735,
										37738
									],
									[
										37944,
										37947
									],
									[
										38113,
										38116
									],
									[
										38371,
										38374
									],
									[
										38656,
										38659
									],
									[
										38829,
										38832
									],
									[
										38915,
										38918
									],
									[
										39156,
										39159
									],
									[
										39275,
										39278
									],
									[
										39310,
										39313
									],
									[
										39533,
										39536
									],
									[
										39655,
										39658
									],
									[
										39889,
										39892
									],
									[
										40170,
										40173
									],
									[
										40316,
										40319
									],
									[
										40352,
										40355
									],
									[
										40566,
										40569
									],
									[
										40852,
										40855
									],
									[
										40970,
										40973
									],
									[
										41007,
										41010
									],
									[
										41227,
										41230
									],
									[
										41478,
										41481
									],
									[
										41625,
										41628
									],
									[
										41675,
										41678
									],
									[
										41895,
										41898
									],
									[
										42006,
										42009
									],
									[
										42178,
										42181
									],
									[
										42368,
										42371
									],
									[
										42554,
										42557
									],
									[
										42672,
										42675
									],
									[
										42795,
										42798
									],
									[
										42906,
										42909
									],
									[
										42950,
										42953
									],
									[
										43118,
										43121
									],
									[
										43157,
										43160
									],
									[
										43244,
										43247
									],
									[
										43414,
										43417
									],
									[
										43503,
										43506
									],
									[
										43683,
										43686
									],
									[
										43716,
										43719
									],
									[
										43883,
										43886
									],
									[
										43969,
										43972
									],
									[
										44210,
										44213
									],
									[
										44329,
										44332
									],
									[
										44364,
										44367
									],
									[
										44587,
										44590
									],
									[
										44709,
										44712
									],
									[
										44943,
										44946
									],
									[
										45224,
										45227
									],
									[
										45370,
										45373
									],
									[
										45406,
										45409
									],
									[
										45620,
										45623
									],
									[
										45906,
										45909
									],
									[
										46024,
										46027
									],
									[
										46061,
										46064
									],
									[
										46281,
										46284
									],
									[
										46532,
										46535
									],
									[
										46679,
										46682
									],
									[
										46729,
										46732
									],
									[
										46949,
										46952
									],
									[
										47060,
										47063
									],
									[
										47254,
										47257
									],
									[
										47372,
										47375
									],
									[
										47489,
										47492
									],
									[
										47601,
										47604
									],
									[
										47645,
										47648
									],
									[
										47795,
										47798
									],
									[
										48001,
										48004
									],
									[
										48055,
										48058
									],
									[
										48109,
										48112
									],
									[
										48227,
										48230
									],
									[
										48477,
										48480
									],
									[
										48499,
										48502
									],
									[
										48542,
										48545
									],
									[
										48560,
										48563
									],
									[
										48614,
										48617
									],
									[
										48705,
										48708
									],
									[
										48869,
										48872
									],
									[
										48990,
										48993
									],
									[
										49112,
										49115
									],
									[
										49143,
										49146
									],
									[
										49177,
										49180
									],
									[
										49206,
										49209
									],
									[
										49420,
										49423
									],
									[
										49506,
										49509
									],
									[
										49746,
										49749
									],
									[
										49865,
										49868
									],
									[
										49900,
										49903
									],
									[
										50122,
										50125
									],
									[
										50244,
										50247
									],
									[
										50477,
										50480
									],
									[
										50757,
										50760
									],
									[
										50903,
										50906
									],
									[
										50939,
										50942
									],
									[
										51153,
										51156
									],
									[
										51439,
										51442
									],
									[
										51557,
										51560
									],
									[
										51594,
										51597
									],
									[
										51814,
										51817
									],
									[
										52065,
										52068
									],
									[
										52212,
										52215
									],
									[
										52262,
										52265
									],
									[
										52482,
										52485
									],
									[
										52593,
										52596
									],
									[
										52787,
										52790
									],
									[
										52905,
										52908
									],
									[
										53025,
										53028
									],
									[
										53137,
										53140
									],
									[
										53181,
										53184
									],
									[
										53338,
										53341
									],
									[
										53424,
										53427
									],
									[
										53664,
										53667
									],
									[
										53783,
										53786
									],
									[
										53818,
										53821
									],
									[
										54040,
										54043
									],
									[
										54162,
										54165
									],
									[
										54395,
										54398
									],
									[
										54675,
										54678
									],
									[
										54821,
										54824
									],
									[
										54857,
										54860
									],
									[
										55071,
										55074
									],
									[
										55357,
										55360
									],
									[
										55475,
										55478
									],
									[
										55512,
										55515
									],
									[
										55732,
										55735
									],
									[
										55983,
										55986
									],
									[
										56130,
										56133
									],
									[
										56180,
										56183
									],
									[
										56400,
										56403
									],
									[
										56511,
										56514
									],
									[
										56703,
										56706
									],
									[
										56819,
										56822
									],
									[
										56939,
										56942
									],
									[
										57051,
										57054
									],
									[
										57095,
										57098
									],
									[
										57342,
										57345
									],
									[
										57435,
										57438
									],
									[
										57457,
										57460
									],
									[
										57591,
										57594
									],
									[
										57629,
										57632
									],
									[
										57752,
										57755
									],
									[
										57845,
										57848
									],
									[
										58011,
										58014
									],
									[
										58093,
										58096
									],
									[
										58328,
										58331
									],
									[
										58382,
										58385
									],
									[
										58406,
										58409
									],
									[
										58530,
										58533
									],
									[
										58584,
										58587
									],
									[
										58608,
										58611
									],
									[
										58742,
										58745
									],
									[
										58847,
										58850
									],
									[
										59084,
										59087
									],
									[
										59285,
										59288
									],
									[
										59468,
										59471
									],
									[
										59648,
										59651
									],
									[
										59917,
										59920
									],
									[
										60088,
										60091
									],
									[
										60349,
										60352
									],
									[
										60372,
										60375
									],
									[
										60543,
										60546
									],
									[
										60820,
										60823
									],
									[
										60999,
										61002
									],
									[
										61026,
										61029
									],
									[
										61142,
										61145
									],
									[
										61345,
										61348
									],
									[
										61547,
										61550
									],
									[
										61841,
										61844
									],
									[
										61868,
										61871
									],
									[
										62042,
										62045
									],
									[
										62291,
										62294
									],
									[
										62329,
										62332
									],
									[
										62474,
										62477
									],
									[
										62512,
										62515
									],
									[
										62681,
										62684
									],
									[
										62767,
										62770
									],
									[
										63008,
										63011
									],
									[
										63127,
										63130
									],
									[
										63162,
										63165
									],
									[
										63385,
										63388
									],
									[
										63507,
										63510
									],
									[
										63741,
										63744
									],
									[
										64022,
										64025
									],
									[
										64168,
										64171
									],
									[
										64204,
										64207
									],
									[
										64418,
										64421
									],
									[
										64704,
										64707
									],
									[
										64822,
										64825
									],
									[
										64859,
										64862
									],
									[
										65079,
										65082
									],
									[
										65330,
										65333
									],
									[
										65477,
										65480
									],
									[
										65527,
										65530
									],
									[
										65747,
										65750
									],
									[
										65858,
										65861
									],
									[
										66048,
										66051
									],
									[
										66178,
										66181
									],
									[
										66245,
										66248
									],
									[
										66277,
										66280
									],
									[
										66300,
										66303
									],
									[
										66402,
										66405
									],
									[
										66429,
										66432
									],
									[
										66545,
										66548
									],
									[
										66681,
										66684
									],
									[
										66719,
										66722
									],
									[
										66933,
										66936
									],
									[
										67049,
										67052
									],
									[
										67169,
										67172
									],
									[
										67281,
										67284
									],
									[
										67325,
										67328
									],
									[
										67513,
										67516
									],
									[
										67793,
										67796
									],
									[
										67974,
										67977
									],
									[
										68126,
										68129
									],
									[
										68212,
										68215
									],
									[
										68452,
										68455
									],
									[
										68571,
										68574
									],
									[
										68606,
										68609
									],
									[
										68828,
										68831
									],
									[
										68950,
										68953
									],
									[
										69184,
										69187
									],
									[
										69464,
										69467
									],
									[
										69610,
										69613
									],
									[
										69646,
										69649
									],
									[
										69860,
										69863
									],
									[
										70146,
										70149
									],
									[
										70264,
										70267
									],
									[
										70301,
										70304
									],
									[
										70521,
										70524
									],
									[
										70772,
										70775
									],
									[
										70919,
										70922
									],
									[
										70969,
										70972
									],
									[
										71189,
										71192
									],
									[
										71300,
										71303
									],
									[
										71495,
										71498
									],
									[
										71614,
										71617
									],
									[
										71734,
										71737
									],
									[
										71846,
										71849
									],
									[
										71890,
										71893
									],
									[
										72050,
										72053
									],
									[
										72176,
										72179
									],
									[
										72275,
										72278
									],
									[
										72433,
										72436
									],
									[
										72480,
										72483
									],
									[
										72646,
										72649
									],
									[
										72697,
										72700
									],
									[
										72802,
										72805
									],
									[
										72855,
										72858
									],
									[
										73031,
										73034
									],
									[
										73183,
										73186
									],
									[
										73345,
										73348
									],
									[
										73485,
										73488
									],
									[
										73564,
										73567
									],
									[
										73659,
										73662
									],
									[
										73792,
										73795
									],
									[
										73871,
										73874
									],
									[
										73966,
										73969
									],
									[
										74090,
										74093
									],
									[
										74225,
										74228
									],
									[
										74405,
										74408
									],
									[
										74628,
										74631
									],
									[
										74880,
										74883
									],
									[
										75144,
										75147
									],
									[
										75337,
										75340
									],
									[
										75530,
										75533
									],
									[
										75753,
										75756
									],
									[
										75979,
										75982
									],
									[
										76369,
										76372
									],
									[
										76410,
										76413
									],
									[
										76745,
										76748
									],
									[
										77033,
										77036
									],
									[
										77173,
										77176
									],
									[
										77210,
										77213
									],
									[
										77310,
										77313
									],
									[
										77360,
										77363
									],
									[
										77509,
										77512
									],
									[
										77578,
										77581
									],
									[
										77617,
										77620
									],
									[
										77712,
										77715
									],
									[
										77970,
										77973
									],
									[
										78059,
										78062
									],
									[
										78228,
										78231
									],
									[
										78259,
										78262
									],
									[
										78294,
										78297
									],
									[
										78324,
										78327
									],
									[
										78442,
										78445
									],
									[
										78594,
										78597
									],
									[
										78618,
										78621
									],
									[
										78648,
										78651
									],
									[
										78678,
										78681
									],
									[
										78811,
										78814
									],
									[
										79030,
										79033
									],
									[
										79118,
										79121
									],
									[
										79203,
										79206
									],
									[
										79376,
										79379
									],
									[
										79571,
										79574
									],
									[
										79766,
										79769
									],
									[
										80106,
										80109
									],
									[
										80248,
										80251
									],
									[
										80311,
										80314
									],
									[
										80551,
										80554
									],
									[
										80574,
										80577
									],
									[
										80717,
										80720
									],
									[
										80735,
										80738
									],
									[
										80771,
										80774
									],
									[
										80922,
										80925
									],
									[
										81041,
										81044
									],
									[
										81165,
										81168
									],
									[
										81266,
										81269
									],
									[
										81414,
										81417
									],
									[
										81508,
										81511
									],
									[
										81656,
										81659
									],
									[
										81674,
										81677
									],
									[
										81705,
										81708
									],
									[
										81769,
										81772
									],
									[
										81921,
										81924
									],
									[
										81975,
										81978
									],
									[
										82111,
										82114
									],
									[
										82277,
										82280
									],
									[
										82437,
										82440
									],
									[
										82615,
										82618
									],
									[
										82744,
										82747
									],
									[
										82873,
										82876
									],
									[
										82995,
										82998
									],
									[
										83078,
										83081
									],
									[
										83177,
										83180
									],
									[
										83303,
										83306
									],
									[
										83407,
										83410
									],
									[
										83536,
										83539
									],
									[
										83635,
										83638
									],
									[
										83772,
										83775
									],
									[
										83874,
										83877
									],
									[
										83947,
										83950
									],
									[
										84028,
										84031
									],
									[
										84294,
										84297
									],
									[
										84320,
										84323
									],
									[
										84415,
										84418
									],
									[
										84658,
										84661
									],
									[
										84810,
										84813
									],
									[
										84879,
										84882
									],
									[
										85125,
										85128
									],
									[
										85229,
										85232
									],
									[
										85489,
										85492
									],
									[
										85545,
										85548
									],
									[
										85617,
										85620
									],
									[
										85828,
										85831
									],
									[
										85880,
										85883
									],
									[
										86112,
										86115
									],
									[
										86276,
										86279
									],
									[
										86362,
										86365
									],
									[
										86602,
										86605
									],
									[
										86721,
										86724
									],
									[
										86756,
										86759
									],
									[
										86978,
										86981
									],
									[
										87100,
										87103
									],
									[
										87334,
										87337
									],
									[
										87614,
										87617
									],
									[
										87760,
										87763
									],
									[
										87796,
										87799
									],
									[
										88010,
										88013
									],
									[
										88296,
										88299
									],
									[
										88414,
										88417
									],
									[
										88451,
										88454
									],
									[
										88671,
										88674
									],
									[
										88922,
										88925
									],
									[
										89069,
										89072
									],
									[
										89119,
										89122
									],
									[
										89339,
										89342
									],
									[
										89450,
										89453
									],
									[
										89642,
										89645
									],
									[
										89758,
										89761
									],
									[
										89878,
										89881
									],
									[
										89990,
										89993
									],
									[
										90034,
										90037
									],
									[
										90172,
										90175
									],
									[
										90284,
										90287
									],
									[
										90456,
										90459
									],
									[
										90606,
										90609
									],
									[
										90631,
										90634
									],
									[
										90770,
										90773
									],
									[
										90919,
										90922
									],
									[
										91073,
										91076
									],
									[
										91175,
										91178
									],
									[
										91374,
										91377
									],
									[
										91405,
										91408
									],
									[
										91436,
										91439
									],
									[
										91467,
										91470
									],
									[
										91573,
										91576
									],
									[
										91771,
										91774
									],
									[
										91970,
										91973
									],
									[
										92168,
										92171
									],
									[
										92370,
										92373
									],
									[
										92661,
										92664
									],
									[
										92805,
										92808
									],
									[
										93079,
										93082
									],
									[
										93262,
										93265
									],
									[
										93287,
										93290
									],
									[
										93457,
										93460
									],
									[
										93666,
										93669
									],
									[
										93803,
										93806
									],
									[
										93831,
										93834
									],
									[
										94076,
										94079
									],
									[
										94290,
										94293
									],
									[
										94426,
										94429
									],
									[
										94453,
										94456
									],
									[
										94471,
										94474
									],
									[
										94672,
										94675
									],
									[
										94883,
										94886
									],
									[
										95019,
										95022
									],
									[
										95046,
										95049
									],
									[
										95064,
										95067
									],
									[
										95265,
										95268
									],
									[
										95476,
										95479
									],
									[
										95612,
										95615
									],
									[
										95639,
										95642
									],
									[
										95841,
										95844
									],
									[
										96052,
										96055
									],
									[
										96291,
										96294
									],
									[
										96456,
										96459
									],
									[
										96782,
										96785
									],
									[
										97032,
										97035
									],
									[
										97059,
										97062
									],
									[
										97238,
										97241
									],
									[
										97265,
										97268
									],
									[
										97588,
										97591
									],
									[
										97898,
										97901
									],
									[
										98102,
										98105
									],
									[
										98129,
										98132
									],
									[
										98285,
										98288
									],
									[
										98453,
										98456
									],
									[
										98779,
										98782
									],
									[
										99061,
										99064
									],
									[
										99222,
										99225
									],
									[
										99548,
										99551
									],
									[
										99822,
										99825
									],
									[
										100137,
										100140
									],
									[
										100312,
										100315
									],
									[
										100357,
										100360
									],
									[
										100382,
										100385
									],
									[
										100411,
										100414
									],
									[
										100548,
										100551
									],
									[
										100591,
										100594
									],
									[
										100833,
										100836
									],
									[
										101009,
										101012
									],
									[
										101196,
										101199
									],
									[
										101317,
										101320
									],
									[
										101426,
										101429
									],
									[
										101613,
										101616
									],
									[
										101724,
										101727
									],
									[
										101755,
										101758
									],
									[
										101941,
										101944
									],
									[
										102057,
										102060
									],
									[
										102245,
										102248
									],
									[
										102352,
										102355
									],
									[
										102473,
										102476
									],
									[
										102503,
										102506
									],
									[
										102706,
										102709
									],
									[
										102964,
										102967
									],
									[
										103098,
										103101
									],
									[
										103114,
										103117
									],
									[
										103146,
										103149
									],
									[
										103345,
										103348
									],
									[
										103376,
										103379
									],
									[
										103407,
										103410
									],
									[
										103438,
										103441
									],
									[
										103588,
										103591
									],
									[
										103806,
										103809
									],
									[
										103983,
										103986
									],
									[
										104182,
										104185
									],
									[
										104384,
										104387
									],
									[
										104582,
										104585
									],
									[
										104805,
										104808
									],
									[
										104891,
										104894
									],
									[
										105148,
										105151
									],
									[
										105271,
										105274
									],
									[
										105306,
										105309
									],
									[
										105541,
										105544
									],
									[
										105667,
										105670
									],
									[
										105913,
										105916
									],
									[
										106214,
										106217
									],
									[
										106364,
										106367
									],
									[
										106400,
										106403
									],
									[
										106626,
										106629
									],
									[
										106932,
										106935
									],
									[
										107054,
										107057
									],
									[
										107091,
										107094
									],
									[
										107323,
										107326
									],
									[
										107590,
										107593
									],
									[
										107745,
										107748
									],
									[
										107795,
										107798
									],
									[
										108027,
										108030
									],
									[
										108138,
										108141
									],
									[
										108292,
										108295
									],
									[
										108349,
										108352
									],
									[
										108446,
										108449
									],
									[
										108492,
										108495
									],
									[
										108583,
										108586
									],
									[
										108628,
										108631
									],
									[
										108655,
										108658
									],
									[
										108699,
										108702
									],
									[
										108744,
										108747
									],
									[
										108771,
										108774
									],
									[
										108815,
										108818
									],
									[
										108860,
										108863
									],
									[
										108984,
										108987
									],
									[
										109086,
										109089
									],
									[
										109140,
										109143
									],
									[
										109171,
										109174
									],
									[
										109202,
										109205
									],
									[
										109233,
										109236
									],
									[
										109264,
										109267
									],
									[
										109370,
										109373
									],
									[
										109500,
										109503
									],
									[
										109652,
										109655
									],
									[
										109787,
										109790
									],
									[
										109920,
										109923
									],
									[
										110147,
										110150
									],
									[
										110311,
										110314
									],
									[
										110336,
										110339
									],
									[
										110387,
										110390
									],
									[
										110536,
										110539
									],
									[
										110577,
										110580
									],
									[
										110605,
										110608
									],
									[
										110686,
										110689
									],
									[
										110826,
										110829
									],
									[
										110867,
										110870
									],
									[
										110894,
										110897
									],
									[
										110912,
										110915
									],
									[
										110949,
										110952
									],
									[
										111094,
										111097
									],
									[
										111135,
										111138
									],
									[
										111162,
										111165
									],
									[
										111180,
										111183
									],
									[
										111217,
										111220
									],
									[
										111362,
										111365
									],
									[
										111403,
										111406
									],
									[
										111430,
										111433
									],
									[
										111468,
										111471
									],
									[
										111612,
										111615
									],
									[
										111717,
										111720
									],
									[
										111846,
										111849
									],
									[
										111873,
										111876
									],
									[
										111991,
										111994
									],
									[
										112108,
										112111
									],
									[
										112188,
										112191
									],
									[
										112230,
										112233
									],
									[
										112275,
										112278
									],
									[
										112320,
										112323
									],
									[
										112365,
										112368
									],
									[
										112390,
										112393
									],
									[
										112419,
										112422
									],
									[
										112493,
										112496
									],
									[
										112536,
										112539
									],
									[
										112638,
										112641
									],
									[
										112706,
										112709
									],
									[
										112795,
										112798
									],
									[
										112863,
										112866
									],
									[
										112952,
										112955
									],
									[
										112983,
										112986
									],
									[
										113078,
										113081
									],
									[
										113147,
										113150
									],
									[
										113234,
										113237
									],
									[
										113349,
										113352
									],
									[
										113379,
										113382
									],
									[
										113493,
										113496
									],
									[
										113604,
										113607
									],
									[
										113620,
										113623
									],
									[
										113652,
										113655
									],
									[
										113703,
										113706
									],
									[
										113734,
										113737
									],
									[
										113765,
										113768
									],
									[
										113796,
										113799
									],
									[
										113827,
										113830
									],
									[
										113953,
										113956
									],
									[
										114102,
										114105
									],
									[
										114242,
										114245
									],
									[
										114395,
										114398
									],
									[
										114544,
										114547
									],
									[
										114738,
										114741
									],
									[
										114854,
										114857
									],
									[
										114974,
										114977
									],
									[
										115089,
										115092
									],
									[
										115133,
										115136
									],
									[
										115262,
										115265
									],
									[
										115422,
										115425
									],
									[
										115574,
										115577
									],
									[
										115716,
										115719
									],
									[
										115880,
										115883
									],
									[
										116038,
										116041
									],
									[
										116313,
										116316
									],
									[
										116464,
										116467
									],
									[
										116621,
										116624
									],
									[
										116784,
										116787
									],
									[
										116942,
										116945
									],
									[
										117089,
										117092
									],
									[
										117175,
										117178
									],
									[
										117416,
										117419
									],
									[
										117535,
										117538
									],
									[
										117570,
										117573
									],
									[
										117793,
										117796
									],
									[
										117915,
										117918
									],
									[
										118149,
										118152
									],
									[
										118430,
										118433
									],
									[
										118576,
										118579
									],
									[
										118612,
										118615
									],
									[
										118826,
										118829
									],
									[
										119112,
										119115
									],
									[
										119230,
										119233
									],
									[
										119267,
										119270
									],
									[
										119487,
										119490
									],
									[
										119738,
										119741
									],
									[
										119885,
										119888
									],
									[
										119935,
										119938
									],
									[
										120155,
										120158
									],
									[
										120266,
										120269
									],
									[
										120396,
										120399
									],
									[
										120651,
										120654
									],
									[
										120699,
										120702
									],
									[
										120866,
										120869
									],
									[
										120931,
										120934
									],
									[
										121053,
										121056
									],
									[
										121065,
										121068
									],
									[
										121244,
										121247
									],
									[
										121291,
										121294
									],
									[
										121411,
										121414
									],
									[
										121531,
										121534
									],
									[
										121643,
										121646
									],
									[
										121687,
										121690
									],
									[
										121804,
										121807
									],
									[
										121933,
										121936
									],
									[
										122038,
										122041
									],
									[
										122103,
										122106
									],
									[
										122201,
										122204
									],
									[
										122342,
										122345
									],
									[
										122364,
										122367
									],
									[
										122654,
										122657
									],
									[
										122734,
										122737
									],
									[
										122821,
										122824
									],
									[
										122928,
										122931
									],
									[
										123125,
										123128
									],
									[
										123306,
										123309
									],
									[
										123467,
										123470
									],
									[
										123512,
										123515
									],
									[
										123535,
										123538
									],
									[
										123686,
										123689
									],
									[
										123803,
										123806
									],
									[
										124020,
										124023
									],
									[
										124168,
										124171
									],
									[
										124235,
										124238
									],
									[
										124302,
										124305
									],
									[
										124352,
										124355
									],
									[
										124356,
										124359
									],
									[
										124510,
										124513
									],
									[
										124576,
										124579
									],
									[
										124656,
										124659
									],
									[
										124757,
										124760
									],
									[
										124884,
										124887
									],
									[
										125111,
										125114
									],
									[
										125172,
										125175
									],
									[
										125225,
										125228
									],
									[
										125380,
										125383
									],
									[
										125467,
										125470
									],
									[
										125556,
										125559
									],
									[
										125653,
										125656
									],
									[
										125744,
										125747
									],
									[
										125852,
										125855
									],
									[
										125877,
										125880
									],
									[
										126043,
										126046
									],
									[
										126089,
										126092
									],
									[
										126112,
										126115
									],
									[
										126292,
										126295
									],
									[
										126346,
										126349
									],
									[
										126483,
										126486
									],
									[
										126515,
										126518
									],
									[
										126610,
										126613
									],
									[
										126737,
										126740
									],
									[
										126852,
										126855
									],
									[
										126971,
										126974
									],
									[
										126996,
										126999
									],
									[
										127037,
										127040
									],
									[
										127179,
										127182
									],
									[
										127244,
										127247
									],
									[
										127401,
										127404
									],
									[
										127518,
										127521
									],
									[
										127659,
										127662
									],
									[
										127700,
										127703
									],
									[
										127844,
										127847
									],
									[
										127986,
										127989
									],
									[
										128094,
										128097
									],
									[
										128296,
										128299
									],
									[
										128634,
										128637
									],
									[
										128743,
										128746
									],
									[
										128850,
										128853
									],
									[
										128985,
										128988
									],
									[
										129070,
										129073
									],
									[
										129180,
										129183
									],
									[
										129255,
										129258
									],
									[
										129364,
										129367
									],
									[
										129487,
										129490
									],
									[
										129593,
										129596
									],
									[
										129733,
										129736
									],
									[
										129858,
										129861
									],
									[
										129886,
										129889
									],
									[
										129962,
										129965
									],
									[
										130002,
										130005
									],
									[
										130120,
										130123
									],
									[
										130368,
										130371
									],
									[
										130557,
										130560
									],
									[
										130837,
										130840
									],
									[
										130968,
										130971
									],
									[
										131054,
										131057
									],
									[
										131312,
										131315
									],
									[
										131435,
										131438
									],
									[
										131470,
										131473
									],
									[
										131706,
										131709
									],
									[
										131832,
										131835
									],
									[
										132079,
										132082
									],
									[
										132381,
										132384
									],
									[
										132531,
										132534
									],
									[
										132567,
										132570
									],
									[
										132794,
										132797
									],
									[
										133101,
										133104
									],
									[
										133223,
										133226
									],
									[
										133260,
										133263
									],
									[
										133493,
										133496
									],
									[
										133761,
										133764
									],
									[
										133917,
										133920
									],
									[
										133967,
										133970
									],
									[
										134200,
										134203
									],
									[
										134311,
										134314
									],
									[
										134490,
										134493
									],
									[
										134640,
										134643
									],
									[
										134916,
										134919
									],
									[
										135095,
										135098
									],
									[
										135220,
										135223
									],
									[
										135347,
										135350
									],
									[
										135470,
										135473
									],
									[
										135514,
										135517
									],
									[
										135714,
										135717
									],
									[
										135935,
										135938
									],
									[
										136066,
										136069
									],
									[
										136305,
										136308
									],
									[
										136631,
										136634
									],
									[
										136927,
										136930
									],
									[
										137035,
										137038
									],
									[
										137207,
										137210
									],
									[
										137379,
										137382
									],
									[
										137585,
										137588
									],
									[
										137892,
										137895
									],
									[
										138081,
										138084
									],
									[
										138167,
										138170
									],
									[
										138408,
										138411
									],
									[
										138527,
										138530
									],
									[
										138562,
										138565
									],
									[
										138785,
										138788
									],
									[
										138907,
										138910
									],
									[
										139141,
										139144
									],
									[
										139422,
										139425
									],
									[
										139568,
										139571
									],
									[
										139604,
										139607
									],
									[
										139818,
										139821
									],
									[
										140104,
										140107
									],
									[
										140222,
										140225
									],
									[
										140259,
										140262
									],
									[
										140479,
										140482
									],
									[
										140730,
										140733
									],
									[
										140877,
										140880
									],
									[
										140927,
										140930
									],
									[
										141147,
										141150
									],
									[
										141258,
										141261
									],
									[
										141435,
										141438
									],
									[
										141641,
										141644
									],
									[
										141757,
										141760
									],
									[
										141877,
										141880
									],
									[
										141988,
										141991
									],
									[
										142032,
										142035
									],
									[
										142171,
										142174
									],
									[
										142248,
										142251
									],
									[
										142310,
										142313
									],
									[
										142410,
										142413
									],
									[
										142473,
										142476
									],
									[
										142677,
										142680
									],
									[
										142861,
										142864
									],
									[
										143029,
										143032
									],
									[
										143115,
										143118
									],
									[
										143355,
										143358
									],
									[
										143474,
										143477
									],
									[
										143509,
										143512
									],
									[
										143731,
										143734
									],
									[
										143853,
										143856
									],
									[
										144086,
										144089
									],
									[
										144366,
										144369
									],
									[
										144512,
										144515
									],
									[
										144548,
										144551
									],
									[
										144761,
										144764
									],
									[
										145046,
										145049
									],
									[
										145164,
										145167
									],
									[
										145201,
										145204
									],
									[
										145421,
										145424
									],
									[
										145672,
										145675
									],
									[
										145819,
										145822
									],
									[
										145869,
										145872
									],
									[
										146089,
										146092
									],
									[
										146200,
										146203
									],
									[
										146396,
										146399
									],
									[
										146516,
										146519
									],
									[
										146636,
										146639
									],
									[
										146748,
										146751
									],
									[
										146792,
										146795
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								10138,
								10144
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"output_tag": 1,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 5099.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "init.c",
					"settings":
					{
						"buffer_size": 649,
						"regions":
						{
						},
						"selection":
						[
							[
								484,
								484
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "sh.c",
					"settings":
					{
						"buffer_size": 8307,
						"regions":
						{
						},
						"selection":
						[
							[
								1109,
								1109
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 944.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "fs.c",
					"settings":
					{
						"buffer_size": 14877,
						"regions":
						{
						},
						"selection":
						[
							[
								836,
								836
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "defs.h",
					"settings":
					{
						"buffer_size": 5280,
						"regions":
						{
						},
						"selection":
						[
							[
								1383,
								1383
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 663.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "echo.c",
					"settings":
					{
						"buffer_size": 198,
						"regions":
						{
						},
						"selection":
						[
							[
								55,
								55
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"exec",
				"exec.c"
			],
			[
				"defs",
				"defs.h"
			],
			[
				"exe",
				"exec.c"
			],
			[
				"co",
				"console.c"
			],
			[
				"cons",
				"console.c"
			],
			[
				"fs.c",
				"fs.c"
			],
			[
				"ex",
				"exec.c"
			],
			[
				"sh",
				"sh.c"
			],
			[
				"s",
				"sh.c"
			],
			[
				"init",
				"init.c"
			],
			[
				"",
				"exec.c"
			],
			[
				"sh.c",
				"sh.c"
			],
			[
				"init.",
				"init.c"
			],
			[
				"con",
				"console.c"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"selected_items":
		[
			[
				"",
				"/home/oron/os142/assignment1/question1.sublime-project"
			]
		],
		"width": 380.0
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true
}
